---
 ---
title: Use Vim editer
author: 曹洋
main: 致敬陈皓和Bram Moolenaar
---
---



[toc]

# 一、Vim 配置文件
[实用配置文件](#实用配置文件)

> 在vim启动过程中，首先将查找配置文件并执行其中的命令。初始化文件一般有vimrc、gvimrc和exrc三种。

vim内查看`:version`可以查看配置文件的详细列表

终端命令行查看 `vim --version`



## vimrc

vimrc是主配置文件，它有全局和用户两种版本。

全局global vimrc文件，存放在Vim的安装目录中。可以使用以下命令，确定Vim的安装目录：

`:echo $VIM`
默认情况下，系统vimrc存放在以下位置：

Linux: `/usr/share/vim/vimrc`

Windows: `c:\program files\vim\vimrc`

用户personal vimrc文件，存放在用户主目录中。

```sehll
可以使用以下命令，确定用户主目录：

命令行查看：
echo $HOME

vim查看
:echo $HOME
```

默认情况下，用户vimrc存放在以下位置：

Linux: `/home/username/.vimrc`

Windows: `c:\documents and settings\username\_vimrc`

用户personal vimrc文件，可以使用以下命令确定：

```vim
命令行查看：
echo $MYVIMRC

vim查看:
echo $MYVIMRC
```

注意：用户配置文件优先于系统配置文件。



## gvimrc

**gvimrc**是GVIM的配置文件，它也有全局和用户两种版本，并且存放在与vimrc相同的目录中。

默认情况下，系统gvimrc存放在以下位置：

Linux:` /usr/share/vim/gvimrc`

Windows: `c:\program files\vim\_gvimrc`

默认情况下，用户gvimrc存放在以下位置：

Linux: `/home/username/.gvimrc`

Windows:` c:\documents and settings\username\_gvimrc`



## exrc

**exrc**文件，仅用于向后兼容olvi/ex，它的全局和用户两种版本也放置于vimrc相同的目录里。除非你使用vi-compatible模式，否则不需要关注exrc配置文件。

注意：在Unix和Linux下，vim的配置文件被命名为以点开头的隐藏文件；而在Windows下，配置文件则以下划线开头命名。



## 编辑配置文件

可以使用以下命令，新建缓冲区来编辑配置文件：

```vim
:edit $MYVIMRC
```

也可以使用以下命令，新建标签页来编辑配置文件：

```vim
:tabedit $MYVIMRC
```



## 应用配置文件

修改配置文件后，需要重新启动Vim，或使用:source命令来应用新的设置：

```vim
:source $MYVIMRC
```

我们可以在配置文件中增加以下命令，在保存后自动应用配置：

```vim
autocmd bufwritepost .vimrc source $MYVIMRC
```



## 配置文件实例

[其它配置](#实用配置文件)

```shell
# vim为了更结构化和模块化的组织vimrc文件，通常会利用自动折叠功能来分节设置各类选项。
# 例如以下语法将设置一个章节，并将具体的选项包含其中：
" Section Name {{{
	set number "This will be folded
" }}}
# 打开vimrc文件之后，将仅仅显示折叠之后的章节结构
```

---

---




# 二、六种模式

> 所谓blank字符就是空格，tab，换行，回车等
> vim 不能使用鼠标操作

- 普通模式：执行 Vim 的指令，此时键盘上的每一个键都是快捷键，能够方便地移动光标/复制 / 删除 / 粘贴文本等等，但是不能进行输入（打字），可以执行一些基本的操作，比如增删改查

  - 默认模式

- 插入模式`insert`：也可以叫做编辑模式

  - 在普通模式下敲击 i 、a 或 o 就进入插入模式，允许用户通过键盘输入、编辑。

- 命令行模式`:`：在普通模式下，先输入冒号:，接着输入命令，就可以通过配置命令对vim进行配置了，如改变颜色主题、显示行号等，这些配置命令也可以保存到/etc/vim/vimrc配置文件中，每次打开默认配置执行。

  - 在命令行模式下，使用 \<ctrl-f> 快捷键打开命令行窗口，并显示命令历史纪录；
    请注意，您可以使用`:set cedit`命令，更改此快捷键。

  - 在常规模式下，使用`q:`命令打开命令行窗口，并显示命令历史纪录；

  - 在常规模式下，使用`q/`命令打开命令行窗口，并显示向前查找（search forward）的历史纪录；

  - 在常规模式下，使用`q?`命令打开命令行窗口，并显示向后查找（search backward）的历史纪录；

  - 我们可以将命令行窗口，视为常规的缓冲区 (Buffer)来操作。使用`k`和`j`键，可以在命令历史纪录中上下移动；也可以使用`/`命令查找命令历史纪录，并在此基础上进行修改，然后点击\<Enter>键来执行命令（命令行窗口也将同时关闭）。

    如果同时打开多个缓冲区 (Buffer)，那么可以在一个缓冲区的命令行窗口使用`yy`命令复制一条命令，然后在另一个缓冲区的命令行窗口中粘贴并执行该命令，或者在命令行中使用`:@"<CR>`来执行复制的命令。也就是说，你可以很方便地在多个缓冲区中，重复执行命令（比如相同的:%s/old/new/g替换操作），而不必多次手工输入命令。

    - 使用以下命令，可以设置命令行窗口的高度（默认值为7）：

      ```shell
      :set cmdwinheight=n
      ```

    - 使用`:q`命令，可以关闭命令行窗口。

    - 使用`:help command-line-window`命令，可以查看命令行窗口的更多帮助信息。

- 可视化模式`visual`：在普通模式下敲击前盘上的 v 键，就进入可视化模式，然后移动光标就可以选中一块文本，常用来完成文本的复制、粘贴、删除等操作。

  - 用`v`命令进入的**字符可视化模式（Characterwise visual mode)**，文本选择是以字符为单位的。
  - 用`V`命令进入的**行可视化模式（Linewise visual mode)**，文本选择是以行为单位的。
  - 用`ctrl-V`进入的**块可视化模式（Blockwise visual mode）**，可以选择一个矩形内的文本。（注意：在Windows中，ctrl-V可能已经被影射为粘贴操作，可以使用`ctrl-Q`进入块可视化模式。）
  - 切换模式
    - 通过输入相应的可视化命令，就可以切换到不同的可视化模式。
    - 例如现在字符可视化模式下，如果想要切换到块可视化模式，那么只需要输入\<ctrl-Q>即可。
    - 当然，我们也可以先用\<ESC>关闭当前的可视化模式，然后再进入其它可视化模式。

- 替换模式`replace`：如果我们想修改某个字符，不需要先进入插入模式，删除，然后再输入新的字符，直接在普通模式下，敲击R键就可以直接替换。

  - 普通替换模式

    ```shell
    R
    ```

  - 单字符替换模式

    ```shell
    r
    ```

  - 虚拟替换模式

    ```shell
    # 虚拟替换模式
    gR
    
    # 虚拟单字符替换模式
    gr
    ```

    - 其与替换模式最主要的区别在于，对\<Tab>键和换行符的不同处理方式。

      - **区别1**：对于\<Tab>键的处理方式

        在替换模式（REPLACE）下，在原有\<Tab>键处输入字母'a'，将直接替代\<Tab>键所占用的所有空格的位置，文本格式遭到破坏：

        ![vim_drops_1](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/vim_drops_1.jpg)

        在虚拟替换模式（VREPLACE）下，在原有\<Tab>键处输入字母'a'，将仅仅替代单个空格，文本格式保持不变：

        ![vim_drops_2](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/vim_drops_2.webp)

        从以上实例可以发现：替换模式（REPLACE）将\<Tab>键作为一个整体来处理（不管其真实占用多少个空格位置）；而虚拟替换模式（VREPLACE）则将\<Tab>键拆分为多个独立的空格来分别处理。如果文本以\<Tab>分隔排布，在编辑过程中希望保持原有的文本缩进和排版格式，那么建议使用虚拟替换模式。

      - **区别2**：对于\<NL>换行的处理方式

        在替换模式（REPLACE）下，输入\<Enter>回车键将增加新行

        ![动图封面](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/vim_drops_3.jpg)

        

        在虚拟替换模式（VREPLACE）下，输入\<Enter>回车键将用新行替代当前行内容（即清空当前行）

        ![动图封面](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/vim_drops_4.jpg)

        使用`gr`命令，可以进入单字符虚拟替换模式。在替换光标下的当前字符之后，将自动返回到常规模式。

- EX模式`ex mode`：类似于命令行模式，可以一次运行多个命令

  - 进入EX模式

    - 终端命令行输入

      ```sehll
      ex filename
      ```

    - Vim编辑器输入

      ```shell
      gq
      或
      Q
      ```

  - 退出EX模式

    - 返回到普通模式

      ```shell
      :vi
      ```

    - 返回到终端命令行

      ```shell
      :q
      ```

      

> 实际上比较常用的的就是编辑模式、普通模式、可视模式、命令模式



## 三、模式切换
- **普通模式 > 插入模式 **

  ```shell
  i/I  # 在光标前面 / 行首插入
  a/A  # 在光标后面 / 行尾插入
  o/O  # 在下 / 上一行行首插入
  ```
- **普通模式 > 替换模式**

  ```shell
  r # 替换当前字符
  shift + r  按ESC退出  # 替换当前字符后，移动到下一个字符，可以继续输入需要替换的词进行替换，输入ESC退出替换模式
  ```
  在普通模式下，按 r 键（小写）可进入替换模式，你可以理解为"replace". 此时你再次输入的字符，可以替换光标处的那个字符

- **普通模式 > 命令模式**

  ```shell
  : #此时光标会跑到编辑器的最底部
  ```
  你可以输入一些命令，按回车执行，执行完命令之后自动回到普通模式，或者你可以直接按 Esc 回到普通模式
  
- **其他模式 > 普通模式**
	
	```shell
	<esc>
	```
	任何模式下，你都可以按 Esc 回到普通模式，一次不行就多按几次，遇事不决 esc
	
	

----

----



# 三、普通模式（默认模式）
> 在此模式下所有的键都是命令键，熟练后可以极大的简化操作



## 1. 插入字符
- 光标处直接插入
	```shell
  i  # insert，从光标位置插入到字符左侧，（光标的前面插入字符）
	a  # append，从光标位置插入到字符右侧，（光标的后面追加字符）
  I  # 从光标处插入到行首，（在一行的开头添加文本）
	A  # 从光标处插入到行尾，（在一行的结尾处添加文本）
  ```

- 光标处新增行插入
	```shell
  o  # 新增下一行，（在当前光标的下一行行首插入字符）
  O  # 新增上一行，（在光标当前行的上一行插入文本）
  ```

- 删除后插入

  ```shell
  s  # 删除当前光标处的字符，并进入到插入模式
  S  # 删除光标所在处的行，并进入到插入模式
  u  # 撤销修改
  ```

- 插入-普通模式

  ```shell
  # 在插入模式中
  <ctrl-o>  # 来进入该模式。
  # 该模式运行用户暂时回到普通模式，然后在执行一条普通模式的命令之后自动回到插入模式中。
  
  <ctrl-o>zz # 刷新光标位置
  <ctrl-o>$  # 刷新到行末
  <ctrl-o>G  # 刷新到文本末尾
  ```
  
- 插入非常用字符
  在平时输入的时候，除了常用的英文单词或者汉字之类的字符还有一些非常用字符，例如unicode 图标或者ascii 字符，或者其他键盘无法直接打出的字符。`vim` 支持使用通过字符的二进制编码进行输入
  
  ```shell
  <ctrl-v>[code]  # 按照字符的十进制编码输入，这里code只能输入单字节的字符
  <ctrl-v>u[code]  # 按照字符的16进制编码输入，这里可以支持两个字节的字符输入，例如unicode
  
  # 输入一个十进制字符
  # 例如可以使用该方式输入字符A，A在ascii表的十进制值是65
  # 在插入模式下
  <ctrl-v>65<enter>  # 即可输入A
  
  # 输入一个是十六进制字符
  # 输入unicode字符的例子，例如我们输入一个安卓的小机器人，通过查询对应的unicode字码表，它的16进制值是 e70e，
  <ctrl-v>ue70e 
  
  # 输入二合字符
  除了输入字符表中的例子，也可以输入二合字符
  <C-k>{char1}{char2}  # 输入二合字符
  <ctrl-v>12  # 输入分数 1/2
  
  # 这个技巧也是 《vim实用技巧》 书中介绍的。
  :h digraph-table  # 查看二合字母表
  ```
  
- 虚拟替换模式
  
  ```shell
  gR  #进入虚拟替换模式，原来的tab键所有空白字符都不会被替换，这样会保持原文本长度。
  gr
  r[char] 和 gr[char]  # 暂时进入替换模式
  ```
  
  

## 2. 移动光标

> 光标信息显示

```shell
<ctrl-G>  # 查看当前的位置状态

<Ctrl-O>  # 向后回退你的光标移动
<Ctrl-I>  # 向前追赶你的光标移动
这两个快捷键很有用，可以在Tab页和Windows中向前和向后trace你的光标键，这也方便你跳转光标。
```



- 方向控制

  ```shell
  h  # 左
  j  # 下
  k  # 上
  l  # 右
  2h  # 向左移动2个字符距离
  ```

  

- 在行内移动
  ```shell
  # 可移动到blank字符
  0  # 移动到行首
  $  # 移动到行尾
  
  # 非blank字符
  g^  # 移动到本行的第一个非空字符  g<shift-6>
  g_  # 移动到本行最后一个非空字符的位置  g<shift-->
  
  2|  # 移到当前行的第2列  ｜是<shift-\>
  ```
  
- 在单词间移动

  ```shell
  w  # 移动到下一个单词词首，符号也会被当作一个单词
  e  # end，移动到当前单词词尾，或下一个单词词尾，符号也会被当作一个单词
  E  # 移动到当前或下一个单词(字符组)的结尾，不记符号，见空格停止
  
  b  # 将光标移动到当前或上一个单词的开头，符号也会被当作一个单词
  ge  # 将光标移动到上一个单词的词末，符号也会被当作一个单词
  
  2w  # 向后移动到第二个单词的位置，符号也会被当作一个单词
  ```



- 全局移动

  ```shell
  # 非blak字符 ####################################################################################
  <enter>  # 移动下一行
  gg  # 移动到第一行的行首，（移动到文件开头）
  G  # 光标移动到最后一行的行首，可以移动到空格
  3G  # 移动到第3行的行首（绝对定位）
  
  
  10gg  # 移动到第10行的行首（绝对定位）
  
  x%  # 按文件比例移动光标位置；移动到文件中间，就使用50%
  H  # <shift-h>移动到home 
  M  # <shift-m>移动到屏幕中间
  L  # <shift-l>移动到一屏末尾
  
  ctrl+G:  查看当前的位置状态
  
  ''  # （2次单引号)返回到跳转前的位置
  ```
  
- 当前行查找并移动
  ```shell
  # 向后移动（记录光标当前的字符）#####################################################################
  fi  # 从光标处后开始查找，光标移动到下一个为i的字符处，你也可以fs到下一个为s的字符
  
  3fa  # 光标移动到：从光标后查找第三个出现a的位置
  tx  # 将光标移动到目标字符x的前一个字符上
  t,  # 移动到本行的下一个为逗号的字符前（左侧），逗号可以变成其它字符
  
  fx和tx可以通过;和,进行重复移动   
  ;  # 正向重复移动  
  ,  # 反向重复移动
  
  # 向前移动（不记录当前的字符）######################################################################
  F 和 T  # 同 f 和 t 一样，只不过是相反方向
  Fa  # 移动到本行的上一个为a的字符处，你也可以Fs到上一个为s的字符
  3Fa  # 光标移动到：从光标前查找第三个出现的a处
  T,  # 移动到本行的上一个为逗号的字符后（右侧），逗号可以变成其它字符
  ```
  ![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/line_moves.jpg)
  
  

  
  
- 文本块移动（上下文移动）
  
  ```shell
  (  # 移到当前句子的开头，（同时满足句点空格或空行）
  )  # 移到下一个句子的开头，（下一个句点空格后的字符或空行）
  {  # 移到当前一段的开头（空行的空格）
  }  # 移到下一段的开头（空行的空格）
  [[  # 移到当前这一节的开头（文本开头）
  ]]  # 移到下一节的开头 （文本末尾）
  ```
  
  - 相对定位上下文移动
  
  ```shell
  # 可以移动到blank字符
  
  # 向下移动
  [num]j  # 向下移动num行
  j   # 向下移动一行
  5j  # 移动到第下面五行
  
  # 向上移动
  [num]k  # 向上移动num行
  k   # 向上移动一行
  4k  #移动到上面第4行
  ```
  
  - 绝对定位上下文移动
  
  ```shell
  :[num]  # 移动到num行
  :5  # 移动到第五行
  ```

>如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）
>如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）



- 匹配移动
  ```shell
  %  # 匹配移动，比如()、{}、[]等，光标需要位于可以匹配的符号上，用于符号间的移动，它会在一对()、[]、{}之间跳跃
	
  \* 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）
	
  你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：
  <start position><command><end position> 
  <开始位置><命令><结尾位置>
  ```
  
  
  
  - 例如
  
    ```shell
    0y$ 命令意味着：
    0  #先到行头
    y  #从这里开始拷贝
    $  #拷贝到本行最后一个字符
    ```
  
    
  
- 对移动指令的操作
  ```shell
  b  # back，移动到上一次的位置
  ```




- 在word间移动

  ```shell
  [num]b	 # 向后移动num个words
  [num]w	 # 向前移动num个words
  [num]e	 # 向前移动num个words,并且将光标置于word的末尾
  [num]ge	 # 向后移动num个words,并且将光标置于WORD的末尾
  ```



- 在WORD间移动
  ```shell
  [num]B	  # 向后移动num个WORDS
  [num]E	  # 向前移动num个WORDS,并且将光标置于WORD的末尾
  [num]gE	  # 向后移动num个WORDS,并且将光标置于WORD的末尾
  [num]W	  # 向前移动num个WORDS
  
	:help word-motions  # 查看在词间移动的更多帮助信息
	```



## 3. 滚屏（翻页）

```shell
# 半屏滚动
<ctrl-u>  # 向前（光标会移动到文本开始处）
<ctrl-d>  # 向后（光标会移动到文本开始处）

# 全屏滚动
<ctrl+b>  # 向前（光标不会移动到文本开始处）
<ctrl+f>  # 向后（光标会移动到文本开始处）

# 光标的位置在屏幕上的移动（不移动内容）
zz  # 将光标置于屏幕的中间
zt  # 将光标移动到屏幕的顶部
zb  # 将光标移动到屏幕的底部
```

- 跳转标记移动 mark

  ```shell
  
  ```
  

## 跳转

- 查看跳转记录

  ```shell
  :jumps  # 查看跳转记录
  # 跳转列表中记录了所在文件以及上次光标所在的行和列。最后几行由于我们处在当前文件中，所以没有列出文件名称来，而是直接给出光标所在行的文本内容，由于我这里打开文件之后立即查看了跳转列表，光标处于第0行这个虚拟行，所以会显示空白内容。
  
  # 它记录了光标所在的行列，所以后面我们在恢复的时候可以直接定位到具体位置。
  
  # 与浏览器类似，之前打开vim的时候访问文件的记录也在里面，它并没有随着vim的关闭而被清除。
  
  # 任何能改变当前窗口中活动文件的命令都可以作为跳转命令，像find、edit 之类的。
  ```

- 跳转

  ```shell
  # 设置跳转标记
  m[a-z]  3 设置跳转标记位置[a-z]
  '[a-z]  # 跳转到标记位置[a-z]
  # mx,my,mz设置三个位置
  # 'x,'y,'z跳转到设置
  
  ``	当前文件中上次跳转动作之前所处的位置
  `.	上次修改的地方
  `^	上次进入插入模式的位置
  `[	上次修改或者复制的起始位置
  `]	上次修改或者复制的结尾位置
  `<	上次高亮选区的起始位置
  `>	上次高亮选区的结尾位置
  
  # 全局书签
  之前先使用mI 插入一个标签，在跳转之后使用 `I 快速跳转回来。 使用与上同
  
  <ctrl-i>  # 来访问前一个跳转
  <ctrl-o>  # 来访问后一个跳转
  # 随意打开一个文件，然后使用edit 打开另一个，接着就可以使用<ctrl-i> 和 <ctrl-o> 在两个文件中切换了
  ```

- 改变列表

  ```shell
  u  # 撤销修改的时候光标总能跳转到对应修改的位置
  \.  # 回到上次修改的位置
  # vim在会话期间会维护一张表，表里记录了每个缓冲区的每一次修改。这个就是所谓的改变列表。可以使用:changes 来查看这个列表
  
  这个列表与跳转列表类似，都标记了行号与列号。我们可以通过
  g,  # 来访问下一个和上一个记录。
  g,  # 来访问下一个和上一个记录。
  你可以拿;和, 来类比记忆。这两个操作符是配合f来使用的。
  ;  # 移动到下一个匹配位置，
  ,  # 移动到下一个匹配位置。
  
  我们可以使用\.来跳转到上一次修改的位置，而 `^则更具体一点。它代表的是上一次退出插入模式光标所在位置。如果我们在做出修改并且退出插入模式之后，移动光标查看了下其他类似代码的实现，然后想快速回到之前编辑的位置继续编辑，可以使用 `^将光标移动到对应位置，然后使用i进入插入模式，
  gi  # 一步到位，直接从上次编辑位置进入插入模式。
  
  # 需要注意的是，vim会为每一个打开的窗口维护一个跳转列表，但是更新列表只有一个，而且跳转列表并不会随着vim的退出而消失，但是改变列表则会随着vim的退出而被清空。
  ```
  
- 跳转到光标下的文件

  ```shell
  在我们将当前项目所在的所有路径加入到path中之后(即在项目根目录中执行:set path+=./**)可以:set将光标移动到对应表示相对路径的代码上
  gf  # 跳转到对应文件。
  ```
  
  ```shell
  vim 中有一个suffixesadd 变量，它保存的当前缓冲区中执行gf操作时，可以使用的扩展。我们可以像设置path 一样，例如:set suffixesadd+=.java 来允许打开java文件。
  ```
  
  

## 4. 复制

```shell
y  # 复制

按【v】 键进入选择模式，然后按h,j,k,l移动光标，选择文本，然后按 【y】 进行复制，按 【p】 进行粘贴。
【dd】剪切一行（前面加个数字可以剪切n行），【p】粘贴
【yy】复制一行（前面加个数字可以复制n行），【p】粘贴
```

- 按单词

  ```shell
  yw  # yank a word 从当前位置开始复制一个词，后面的空格也会复制
  y2w  # 从当前位置开始复制两个词，后面的空格也会复制
  ye  # 从当前位置拷贝到本单词的最后一个字符，不会复制空格
  ```

  

- 按行

  ```shell
  yy  # 复制一整行
  5yy  # 复制5行
  y$  # 复制从当前光标到行结尾的所有单词
  y0  # 复制从当前光标到行首的所有单词
  2yy  # 复制从当前光标所在行开始的2行
  y2/foo  # 从当前位置开始，复制到第二个foo前结束，当前直至最后面的空格也会复制
  ```
  
  
  
- 复制并粘贴

  ```shell
  # 使用t 命令
  # t 命令代表拷贝和粘贴，可以理解为 CopyTo。它需要两个参数，一个范围代表拷贝哪个范围的文本，一个位置，代表要将拷贝的内容放置在哪个位置。它的形式如下:
  :range-t-address
  # 第一个range 代表的是范围，要将哪个范围内的文本进行粘贴，第二个address 代表的是一个行号，要将粘贴的内容放置到哪个位置
  :1,4t7 # 把1-4行的内容复制到第7行
  ```

- 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：

    ```shell
    d[方向/<enter>]  # 删除，会复制blank
    v[方向/<enter>] y  # 可视化的选择，不会复制blank字符 esc确定并退出
    gU[U/<enter>/方向]  # 变大写，按回车执行当前行和下一行
    gu[u/<enter>/方向]  # 变小写，按回车执行当前行和下一行
    ```



## 5. 粘贴

```shell
P  # 在当前位置之后粘贴
p  # 在当前位置之前粘贴
3p  # 在当前位置之前粘贴3次
4P  # 在当前位置之后粘贴4次
```



## 6. 剪切

```shell
y$  # 复制从当前光标到行结尾的所有单词
y0  # 复制从当前光标到行首的所有单词
yy  # 复制一整行
2yy  # 从当前光标所在行开始复制2行
```
- 复制文本块
  ```shell
  1.首先进入visual模式：v
  2.移动光标选择文本
  3.复制与粘贴的操作
  ```

- 互换

  ```shell
  # 使用m命令，移动(交换位置)
  
  :range-m-address
  # 第一个range 代表的是范围，要将哪个范围内的文本进行粘贴，第二个address 代表的是一个行号，要将粘贴的内容放置到哪个位置
  
  :7m5  # 第7行和第五行的位置互换
  :.+2,$m.  # 当前位置偏移两行到末尾的内容与当前位置的内容互换
  ```

  




## 7. 删除

- 删除字符
  ```shell
  dt"  # 在当前行的光标处开始，往后删除所有的内容，直到遇到双引号"，双引号可以是任意字符
  x  # 删除当前光标所在的字符，只有一个字符的会保留行
  dl  # 删除当前光标处的字符=x
  X  # 删除当前光标左边的字符
  dh  # 删除当前光标左边的字符=X
  3d下  # 向下删除3行,可是是任意数字和方向
  ```



- 单词删除（光标处到空格）

  ```shell
  dw  # delete a word，从光标处开始删除一个单词，仅删除 (从光标处到空格)
  
  daw  # 无论光标在什么位置，删除光标所在的整个单词和相连接的空白字符，遇到空格后的字符或符号停止
  diw  # 删除整个单词文本，但是保留空格字符不删除，遇到空格后的字符或符号停止，如果只有空格则删除
  d2w  # 删除从当前光标开始处到2个单词
  d$  # 删除从光标到一行末尾的整个文本
  d0  # 删除从光标到一行开头的所有单词
  ```

  

- 按行删除

  ```shell
  # 光标位置不变，内容移动
  dd  # delete，删除当前光标处的一整行=D
  2dd  # 向下删除从光标开始处的2行代码
  
  dgg  # 删除从光标到文本开头
  dG  # 删除从光标到文本结尾
  
  d3下  # 向下删除3行
  d2上  # 向上删除2行
  d4左  # 向左删除4个字符
  d2右  # 向右删除2个字符
  #d和数字可以交换
  ```

- 删除整个文件

  ```shell
  # 普通模式下
  0dG  # 使用 0 跳转到第一行, 然后使用dG 第一行到最后一行的内容
  
  # 命令模式下
  :1,$d  # 删除第一行到最后一行的内容
  
  # 命令模式下
  :%d  # 删除所有
  
  # 使用位置偏移量来微调操作范围
  # 在 {startpoint}, {endpoint} 中二者均为绝对地址，除了使用绝对地址，我们也可以使用绝对地址+偏移地址的方式来定义操作范围。
  # 可以在绝对地址上使用 + 或者 - 来定义如何进行偏移，例如 $-3 会定位到导数第4行。
  :4,$-3d  # 保留前3行和后3行，使用命令的时候可以使用
  ```

  

- 匹配删除（会进入编辑模式）

  ```shell
  ci{ 或 ci}  # change in，匹配{}，并删除{}里面的内容，然后进入编辑模式
  ```

- 行合并
  ```shell
  J  # 删除一个换行符，将当前行与下一行合并
  ```

- 标记符号

  ```shell
  .  # 当前行
  $  # 文件末尾
  0  # 虚拟行，位于文件第一行的上方
  1  # 文件第一行
  'm  # 包含标记m的行
  <  # 高亮选区的起始行
  >  # 高亮选区的结尾行
  %  # 整个文件，相当于 :1,$
  ```

  

## 8. 选择
- 区域选择 

  ```shell
  <action>a<object> 或 <action>i<object>
  
  action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。
  object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符："、 '、 )、 }、 ]。
  
  a  # 选择<object>内的内容，不包括<object>
  i  # 选择<object>和<object>内的内容，包括<object>
  ```
  
  
  
- 例如

  ```shell
  假设你有一个字符串 (map (+) ("foo"))，而光标键在第一个 o 的位置。
  
  vi"  # 会选择             foo
  va"  # 会选择            "foo"
  vi)  # 会选择            "foo"
  va)  # 会选择           ("foo")
  v2i)  # 会选择  map (+) ("foo")
  v2a)  # 会选择 (map (+) ("foo"))
  ```


  ![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/textobjects.png)

## 9. 块操作

> 给一个块区域执行相同的操作

```shell
<Ctrl-v>  # 开始块操作
# 随着光标上下移动会选择每行光标经过的所有连续单个字符
```

- 字符模式

  ```shell
  v  # 进入字符模式
  ```

  

- 行模式

  ```shell
  V  # 进入行模式
  ```

  

- 块模式

  ```shell
  <ctrl-v> 进入块模式
  ```

- 操作

  ```shell
  A  # 添加是在光标右边
  I  # 插入是在光标左边
  ```

- 案例

  ```shell
  # 在行首插入--
  0 <Ctrl-v> <Ctrl-d> I-- [ESC]
  
  0  # 到行头
  <Ctrl-d>  # 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)，移动20行？
  I  # I是插入
  --  # 插入“--”
  <ESC>  # 退出插入模式和块模式并为每一行生效
  
  
  ########################################################################################
  
  # 目的：移动字符 （复制行首的# 粘贴到行尾）
  
  # 行首创建# 共向下10行
  <ctrl-v> <10j> I # <esc>
  # 删除10行# 自动复制
  <ctrl-v> <10j> d
  # 移动到行尾粘贴
  $ p
  
  <ctrl-v>  # 打开块模式
  10j  # 光标向下移动10行
  I  # 左侧插入
  #  # “#”字符
  <esc>  # 退出，使操作生效
  <ctrl-v>  # 打开块模式
  10j  # 光标向下移动10行
  d  # 删除，默认会复制
  $  # 光标移动到行尾
  p  # 粘贴
  ```

  


![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/rectangular-blocks.gif)

## 10. 更改与替换

```shell
cw  # change a word，从光标处字符开始删除到单词结尾，并进入插入模式
cb  # 删除从光标处到单词开头的文本并进入到插入模式
cc  # 删除一整行并进入到插入模式

r  # 替换当前光标下的字符
2r&  # 将光标位置处2个字符替换为“&&”
R  # 进入到替换模式
s  # 删除一个字符，并进入编辑模式

xp  # 光标处的字符与下一个字符交换

~  # 修改光标下字符的大小写
```



## 11. 字符操作

```shell
guu  # 把一行的文字变成全小写。或是【Vu】
gUU  # 把一行的文件变成全大写。或是【VU】

ga  # 查看光标处字符的ascii码

g8  # 查看光标处字符的utf-8编码

gf  # 打开光标处所指的文件 （这个命令在打到#include头文件时挺好用的，当然，仅限于有路径的）

* 或 #  # 在当前文件中搜索当前光标的单词

<ctrl-a>  # 自增
[num]<ctrl-a>  # 自增[num]

<ctrl-x>  # 自减
[num]<ctrl-x>  # 自减[num]

# 如果光标不在数字所在位置，该命令会在本行往后查找第一个出现数字的地方，并将光标跳转到该处，然后执行加1的操作。
```



## 12. 缩进

```shell
>>  # 向右给它进当前行 
<<  # 向左缩进当前行
=  # 缩进当前行 （和上面不一样的是，它会对齐缩进）
=%  # 把光标位置移到语句块的括号上，然后按=%，缩进整个语句块（%是括号匹配）
G=gg 或是 gg=G  # 缩进整个文件（G是到文件结尾，gg是到文件开头）
```



## 13. 对于vim命令的操作

```shell
.  # 重复上次操作
u  # undo，撤销上一次的操作
<ctrl-r>  # 反撤销
<ctrl-n>  # 自动补全（从已输入的字符查询）
```



## 14. 读取shell

```shell
:r!date  # 插入日期   :r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来，输入到光标处。
```







## 15. 文件操作

```shell
:e dir/file  # 打开dir路径下的file文件
:saveas path/to/file  # 另存为 path/to/file
```





## 16. 重复

```shell
[num]p  # 重复p命令num次

100idesu [ESC]  # 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “
.  # 重复上一个命令—— 100 “desu “.

3.  # 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).

# 当我们在第一行使用 v 进入选择模式，然后使用e 选中一个单词（这个单词占一行），删除它之后，再在下一行执行. 命令的时候，并没有删除一行，只删除了上次删除的单词
```



## 17. 宏录制

```shell
qa  # 操作序列 q, @a, @@
qa  # 把你的操作记录在寄存器 a。于是@a 会replay被录制的宏。
@@ 是一个快捷键用来replay最新录制的宏。

```

- 示例

  ```shell
  # 在一个只有一行且这一行只有“1”的文本中，键入如下命令：
  
  qa Y p <C-rrla> q  # 录制复制行的宏
  
  qa  # 开始录制
  Yp  # 复制行
  <Ctrl-a>  # 增加1
  q  # 停止录制
  @a  # 在 1 下面写下 2 
  @@  # 在 2 正面写下 3
  100@@  # 会创建新的 100 行，并把数据增加到 103
  ```

  


![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/macros.gif)

我们可以这么归纳这个操作，从行首开始找第一个 `.`，然后执行替换操作将其替换为 )然后找到下一个单词，将首字母改为大写。我们可以在宏中执行 `0f.r)w~j`最后退出。读一下这段内容， `~`之前没见过吧。之前介绍过，`gU`和 `gu`后面可以跟 `motion`表示将对应范围的字符转化为大写和小写。`g~`可以进行大小写反转。而这里的`~`直接将当前光标所在字符进行反转。
![宏录制例子](https://img-blog.csdnimg.cn/02fe027af3d94be89eee607e1be7b5db.gif#pic_center)
上述命令我们首先使用 0将光标至于行首，这样就规范了每行的查找操作。另外这里由于 10 有两个字符，所以这里使用 `f` 来查找而不仅仅使用 `l`往后移动一个字符，最后我们不确定`.` 和单词之间会不会有空格。所以这里最好是使用 `w` 而不是 `l` 。这些细节体现了我们之前说的要更加规范的移动光标。

宏录制完了之后，我们可以利用之前介绍的 `motion`失败会终止执行的特性，不用数需要处理多少行，直接 `10@a`（因为第一行已经处理了，所以这里只有9行待处理）

- 以并行的方式执行

  重新录制宏，与之前相比，只需要将j这个操作给去除掉。然后使用针对行的可视模式，选中待处理行，然后针对这些选中行来执行宏。
  我们在这里来审视一下这两种方式，并行方式需要提供重复次数，它是第一次执行完了接着执行下一次，下一次的执行依赖于上一次成功的执行。并行则不然，并行是针对选中部分，同时执行一个宏操作。即使中间有错也不影响其他行的运行。

- 给宏追加命令

  还是上面的例子，假设在录制好了宏之后发现我们少了一个j，使用串行话的方式无法顺利执行。这种情况下不需要重新录制宏，只需要在对应寄存器中添加一条指令。

  这里补充一下寄存器相关知识。在上一篇介绍寄存器的时候我们只演示了使用小写字母的寄存器，没有提到大写字母的寄存器。根据之前的惯例，大写字母与小写字母都可以使用，大写字母的功能比小写字母要强，例如大写的标签标示全局，小写的只能用于单个文件。这里大写的寄存器与小写的寄存器是同一个寄存器，使用大写时我们可以对寄存器内容进行追加操作。

  宏是保存在寄存器中的，q 后面加字母表示宏的内容保存在哪个寄存器中，说到这里，聪明的你已经反应过来该如何将命令追加到寄存器中了。那就是使用 q+大写字母。

  针对并行操作的例子，假设已经录好其他操作只差一个j 了，我们可以使用 qA 进行追加，然后添加 j 操作即可
  
- 配合文件参数列表使用宏
  之前介绍过文件参数列表，即使用 :args 可以对文件进行分组，各位小伙伴可能只知道这个，但是没找到它的使用场景。也不知道vim提供这个功能有什么用处。在这里我们就来看看它的一个使用场景。
  
  我们还是以之前的 neovim 配置文件的工程为例，我要在每个lua文件中添加一行注释 --this is add by vim macro 。打开一个 lua 文件之后，使用 :args **/*.lua 来将每个 lua 文件加入到参数列表中。然后随意打开一个 lua 文件，在录制宏的时候执行 ggO<ESC>S--this is add by vim macro 然后退出。这里还是贯彻了前面说的要是移动更加规范，我们先用 gg 移动到第一行，以便能准确的在首行插入内容。由于在 lua 文件中有注释的话使用 O 添加一行的时候它会自动添加一个注释。但是不能确保所有的 lua 文件在行首都有注释，所以我们先使用 S 删除一行并进入插入模式。当然通过配置也可以取消这个特性，等介绍到文件类型的时候再来讨论这个。
  
  此时文件已经发生了变化，如果我们直接执行宏的话，之前录制时修改的文件将会两次执行相同的命令，所以这里不能保存，可以执行 :edit! 放弃本次修改，或者如果已经修改了的，可以执行u进行回退。
  
  结合之前介绍的在命令模式中执行普通模式的命令，可以使用 :argdo normal @a 。argdo 表示循环对参数列表中的每个文件执行相同的操作
  
- 编辑宏内容

  首先我们需要将 宏从寄存器中放到编辑器中，这就要使用 `:put a`取出寄存器中的内容，你可能会疑惑为什么不用 `"ap` 呢，这是因为` p` 命令默认会将寄存器中的内容放到光标所在位置的后面，而 :put 则会直接放到下一行，所以这里还是放入到当前命令之后要好。接着修改一下这个宏。在对应位置加上 S 这个操作，最后使用 0d$ 从行首粘贴到行尾，注意这里尽量不要使用 dd，它会连带着换行符一块进行粘贴，可能会破坏宏的指令。最后我们可以先删除之前粘贴的一行，再重新执行这个宏

 ### 详解

宏是存储在寄存器中的连续的操作指令，以便后续可以对这些指令进行回放。可以使用 `q` 进行录制，后面跟寄存器名称，表示将接下来的操作记录保存到这个寄存器中。例如使用 `qa` 表示将接下来的操作保存到 `a` 这个寄存器中。退出宏的录制可以直接输入 `q`，我们可以使用 `:reg a` 来查看寄存器的内容。

这个内容完全是我们之前通过键盘输入到vim中的内容，只是返回到普通模式输入的是`<Esc>` 而这个保存的是`^[` 因为宏有自己的键盘编码方式，这个方式我觉得不需要特别去查去记，自己就可以从寄存器中查到。

宏录制完成之后，可以使用 `@ + 寄存器` 来回放寄存器中保存的宏。在回放宏之后可以使用 `@@` 来快速回放上一次回放的宏。

到现在各位小伙伴可能已经发现了，它与`.`命令比较类似，只能机械的执行之前执行过的内容，它无法做到智能化，例如我在录制宏的过程中使用了诸如 `2w`之类的命令，后面在重复的时候很有可能发生错误。这就要求我们在使用宏的过程中，尽量规范化光标移动，不要搞这种特例的形式。就像写代码不要写死一样。

-  `vim` 宏在 `motion` 执行失败之后会终止执行，

# 插入模式

我们可以在普通模式下输入 `/` 进入插入模式。在其后面输入想要查找的字符串，按下`<CR>` 进行查找。此时vim光标会自动跳转到匹配的位置，并将对应位置高亮显示( 这个是 `neovim`的特性，vim高亮可能需要一些配置)。使用 `<Esc>` 将会结束查找，退回到普通模式。

在匹配模式中，可以使用 `n` 来跳转到下一个匹配位置，按下`N` 将跳转到上一个匹配位置。这个查找是循环进行的，也就说在跳转到最后一个匹配位置之后，再使用 `n` 将会跳转到第一个匹配位置。

- 查找

# 四、可视化模式

- 模式切换

  ```shell
  v  # 字符可视化模式，移动上下光标可以选择行，左右移动光标可以选择字符
  
  V  # 行可视化模式，移动光标可以选择一行字符
  
  <shift-v>  # 可视化行，移动光标选择行
  <Ctrl-q>  # 块可视化模式，
  <Ctrl-v>  # 块可视化模式，移动光标可以选择单个字符
  <ctrl-p>  # windows进入可视化块模式
  
  <esc> 或 <ctrl-c>  # 退出可视化模式
  
  # 进入可视模式后
  <ctrl-g>  # 进入选择模式，左下角的字样已经变为 SELECT，表示此时进入了选择模式
  # 在选择模式中，随便输入一个字符，它会删除选中然后输入对应的内容。
  ```

- 切换选择区域/光标

  ```shell
  gv  # 重复前一次可视化模式时选中的文本。如果已经在可视化模式下，执行该命令会选中前一次选择的文本。如果重复行执行gv命令，就会在当前选中的文本和前一次选中的文本之间进行切换。
  
  # 重新选择选区的活动段
  o  # 选中区域首尾切换个光标位置
  O  # 行内切换个光标位置
  ```
  
- 字符操作

  ```shell
  # 删除
  d  # 删除选中的文本
  D  # 删除整行
  
  # 复制
  y  # 复制选中的文本
  Y  # 复制整行
  
  # 删除打开插入模式
  c  # 删除选中的文本，并进入插入模式， 输入<esc>可把内容插入到所有的选中行
  C  # 删除从选中文本到行尾的所有字符，并进入插入模式
  
  # 大小写
  u  # 转小写
  U  # 转大写
  ~  # 进行大小写转换
  
  # 缩进
  >  # 增加缩进
  <  # 减少缩进
  =  # 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）
  
  # 合并
  J  # 将选中的文本内容合并为一行，同时以空格来分隔各行
  gJ  # 将选中的文本内容合并为一行，不在行间插入空格
  
  # 加密
  g？ # 使用rot 13算法来加密或解密高亮显示的文本
  
  #vim8特性
  <Ctrl-a>  # 自动递增
  <Ctrl-a>  # 自动递减
  #如果设置 nformats=alpha，就可以像处理数字一样递增字母表
  ```
  
- 其它命令操作

  ```shell
  # : 键就可以对选定范围进行操作。
  :write block.txt  # 将文本块写入另一文件中
  :sort  # 选择多行后，可以对选中的文本进行排序
  
  
  # 选择行
  rx  # 将选中的每个字符都替换为x
  
  # 选择行
  I # <esc>  # 在选中行的前面添加#
  
  # 选择行
  I # <esc>  # 在选中行的前面添加#，但是两个选中行之间没有被显示为选择的行仍然会在该列添加#
  
  # 当我们在第一行使用 v 进入选择模式，然后使用e 选中一个单词（这个单词占一行），删除它之后，再在下一行执行. 命令的时候，并没有删除一行，只删除了上次删除的单词
  ```
  
- 在被选中行前添加东西

  ```shell
  # 选择行
  I string <Esc>  # 快速地在块可视化模式下添加文本。
  # <shirt-6> 命令，移动到行首；
  # <ctrl-q> 进入块可视化模式；
  [num]j  # 选中多行
  # I--命令，在每行开头增加注释符。
  ```


![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/autoindent.gif)

- 在所有被选择的行后加上点东西：

  ```shell
  $ A string <Esc>
  
  <Ctrl-v>  # 选中相关的行 (可使用 j 或 <Ctrl-d> 或是 /pattern 或是 % 等……)
  $  # 到行最后
  A  # 光标后插入
  string  # 输入字符串
  ESC  # 执行
  ```
  ![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/append-to-many-lines.gif)
- 分屏
  ```shell
  # 分屏 
  :split  # 水平分屏
  :vsplit  # 垂直分屏
  
  :help split  # VIM分屏帮助
  :split  # 创建分屏 (:vsplit创建垂直分屏)
  <Ctrl-w><dir> : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。
  <Ctrl-w>_ (或 <Ctrl-w>|)  # 最大化尺寸 (<C-w>| 垂直分屏)
  <Ctrl-w>+ (或 <Ctrl-w>-)  # 增加尺寸
  ```



![](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/split.gif)

- 帮助

  ```shell
  :help visual  #点击<ctrl-D> 或者 <Tab> 将会列出和可视化相关的帮助主题；再点击 <Tab> 可以选择打开选中的主题
  
  可以在所希望帮助的名称前加v_前缀。例如使用:help v_d命令，可以得到关于在可视模式下进行删除操作的帮助信息。而使用:help v_b_r命令，则可以得到关于在块可视模式下进行替换操作的帮助信息。
  :help Visual-mode  # 查看更多关于可视化模式的帮助信息
  ```

  


# 五、命令行模式`:`

> 命令行模式的特点是光标在底部，并且会前面有一个`:` 或`/`或`?`

输入`:`命令，使用`/`或`?`搜索命令，都将进入命令行模式。

```shell
<shift-;>  # :
<shift-/>  # ?
/  # /
```

用户可以在屏幕底部的命令行中输入命令，或者使用以下快捷键遍历之前的命令历史，然后点击\<Enter>键来执行命令。

## 1. 对于命令行命令的操作

- 移动光标
    ```shell
    上 # 显示上一条命令
    ctrl-p  # 显示上一条命令
    下  # 显示下一条命令
    <ctrl-n>  # 显示下一条命令
    
    <ctrl-b>  # 移动到命令行开头
    <ctrl-e>  # 移动到命令行末尾
    
    <ctrl-左>  # 向左移动一个单词
    <shift-左>  # 向左移动一个单词
    <ctrl-右>  # 向右移动一个单词
    <shift-右>  # 向右移动一个单词
    
    <ctrl-w>  # 删除光标前的一个单词
    <ctrl-u>  # 删除光标前的所有字符
    ```
    
- 历史命令过滤

    ```shell
    :set <上/下>  # 仅显示以set开头的历史命令  :可以替换为/和？
    继续键入命令 :set i 之后，按下 Tab 或 <Ctrl-D> 键，将显示以“i”开头的set命令；继续按 Tab 键，则可以在这些命令列表间移动，按下 <enter> 可以执行该命令
    ```

- 输入命令

    ```shell
    光标位于一个单词或字符，进入命令行模式之后：
    
    点击 <Ctrl-r>  <Ctrl-w> 键可以将当前光标下的word粘贴到命令行
    粘贴光标所在的字符：点击 <Ctrl-r>  <Ctrl-a> 键可以将当前光标下的WORD粘贴到命令行
    粘贴文件名：点击 <Ctrl-r>  % 键可以将当前文件名粘贴到命令行
    
    利用以上快捷键，可以大大简化命令行的输入。
    
    ```

    - 例如

      ```shell
      # 替换光标下的单词
      :substitute
      <Ctrl-r>
      <Ctrl-w>
      即可将光标下的单词插入到命令行中，而不需要手工输入替换的文字了
      ```

- 执行命令

    ```shell
    <enter>
    ```

- 退出到正常模式

  ```shell
  <esc>
  ```

- 直接保存

  ```shell
  ZZ  # 保存，不需要按回车和换行   
  ```

- 输入键盘上找不到的字符

  ```shell
  <Ctrl-v> 
  <Ctrl-k>
  ```
  
  

- 其它

  ```shell
  设置参数含义
  :set nu
  :set nonu显示取消行号:syntax on
  :syntax off是否依据语法显示相关颜色帮助。默认会显示相关颜色来帮助排错:set hlsearch
  :set nohlsearch设置是否将查找的字符串高亮显示。默认是高亮显示:set showmode
  :set noshowmode设置是否在左下角显示如“-INSERT-” 之类的状态栏。默认是开启的:set list
  :set nolist设置是否显示隐藏字符。（tab 键用 "^I" 表示，回车符用 "$" 键表示）
  # 上面设置的参数都只是临时生效，一旦关闭文件再打开，又需要重新输入。如果想要永久生效，需要手动建立 vim 的配置文件 ==“~/vimrc”== ，把你需要的参数写入配置文件就永久生效了。
  
  :print  # 打印当前行
  :2print  # 打印第二行
  
  使用范围的格式格式：
  command = {startpoint},{endpoint}-cmd
  用特殊符号代表对应行
  
  除了使用数字来代表对应行号所在行外，还是使用一些特殊符号来表达一些特殊含义，例如我们可以使用 . 来代表当前光标所在行，所以针对上述操作，我们还有一个解法：使用3gg 跳转到第三行，然后使用 
  :.,5d  # 删除当前行到第5行的内容
  ```


- 配合可视模式
       

  ```shell
  V  # 进入可视模式
  2j  # 选中两行
  :d  # 进行删除
  
  在选中一个选区后，按下 : ， 在左下角会出现 <,> 的字样，根据前面的列表知道，他们代表的是被选中的高亮选区。
  ```

- 使用普通模式命令

    ```shell
    :%moral A  # normal后可以跟一些改变当前模式的命令并且可以指定输入的内容的。
    ```
    
- 重复上次的ex命令

    ```shell
    # 在普通模式下
    .  # 重复上一次的修改，但是某些ex命令并没有对其进行修改，如果我想重复通过`.` 来重复上次的ex命令则无能为力了。而且通过实验也可以发现，它也无法重复由ex命令造成的修改。
    
    # 解决
    @:  # 重复上一次的命令。如果执行过 @: 进行重复，那么可以使用 @@ 再次执行上次重复的命令，例如在编写代码时经常会一到的一个问题就是将当前行代码下移一行，但是也不是所有的行都会这么干，那么就可以先使用 
    .m.+1  # 将当前位置的代码移动到光标的下一行，然后移动光标，在下一个需要次操作的位置执行 @: ，后面就可以直接使用 @@ 来重复上一次的操作了
    ```

- 自动补全ex命令

  ```shell
  # 在使用shell 命令的时候，使用tab 可以很方便的进行补全，而在使用命令模式的时候也有这个功能
  
  # vim在使用tab时会自动检索之前输入的历史进行匹配。
  :%n<tab>  # 会匹配到一堆符合要求的命令。多次按下 <tab> 键则会依次按从上到下的顺序进行匹配。
  
  也可以使用 <Ctrl-n> 和 <Ctrl-p> 跳转到下一次匹配和上一次匹配。
  同样的也可以使用 <Shift-Tab> 来跳转到上一次匹配
  ```
  
  
  
  默认情况下，会按照上述例子中的样式来展示匹配项，但是你也可以自定义匹配项，使用`wildmode` 来修改补全行为。但是需要事先打开 wildmenu 选项。
  
  可以使用` :h wildmode` 和 `:h wildmenu` 来查看对应的帮助文档。
    ```shell
    set wildmenu
    set wildmode=full
    ```

- 回溯历史

  ```shell
  # 在 shell 中，可以使用上下键直接输入上次输入的命令或者在 bash_history 中记录了之前执行过的命令，vim也有同样的设计
  
  # 进入到命令模式之后，可以使用方向键向上或者向下查找历史命令。
  
  除了使用 方向键以外，还可以使用 <Ctrl p> 和 <Ctrl n> 来遍历，但是使用方向键有一个好处是他们可以针对之前已经输入的内容对匹配的内容进行过滤。坏处在于，手指的移动幅度大，我们可以使用映射的方式将<Ctrl-p> 和 <Ctrl-n> 进行映射。
  ```

  

## 运行shell 命令

```shell
################### 在vim的命令模式中也可以执行shell命令。只需要在shell命令前面加上 ! 即可 #####################
:!ls  # 执行ls 这个命令
```

- 配合shell使用
  ```shell
  # 在vim配合shell命令使用的时候有时候shell会产生大量是输入或者需要一定的输出，那么就可以使用 write 和 read 来配合shell使用。
  r  # read：vim从shell产生的输出中读取内容写入缓冲区
  w  # write: vim将缓冲区的内容写入到shell中，作为shell的输入
  
  # 使用 write 和read 命令重定向vim缓冲区内容
  # 例如某个文件中有大量的Python代码，但是我只想执行部分，那么可以配合write使用，
  3,5write !python  # 执行文件中3-5行的Python代码，或者配合可视模式，执行选中的代码
  
  # % 代表的是当前文件名，在运行某些可以传入文件名作为参数的命令时，可以使用
  :r!python %  # 执行当前的Python代码
  ```

  
  - 把输出的内容保存在当前文本内
    
    ```shell
    # 输出文件名
    :r!print %  # r 读取内容到当前文本，！执行shell命令，print打印，%文件名
    
    # 输出一个随机数
    :r!echo $RANDOM  
    
    # 配合sort 使用 
    :2,$!sort  # 从第2行开始排序，仅按照第一个字符排序
    
    :read !ls|sort  # 需要获取当前目录下有多少个文件和目录，并且按照文件名顺序排列，  
    # 甚至配合键绑定，完成ide那种一件自动编译运行的效果。例如
    vim.api.nvim_set_keymap('n', '<F5>', ':write | !python %<CR>', {noremap = true, silent = true})
    ```

    除了手工填写范围配合shell命令之外，vim提供了一种简便的方式来完成这一工作，可以使用 !{motion} 来快速形成范围，后面只需要输入命令即可，针对前面排序文件的例子，假设光标在文件的第二行，可以使用在普通模式下输入!G 来快速选中整行，vim为我们在右下角填充了`:.,$! `后面只需要写上`sort` 之后就可以了

## 文本操作

```shell
:range-[t/m]-address
```

- 拷贝粘贴

  ```shell
  # t (拷贝粘贴) 和 m （移动）

  # 使用t 命令
  # t 命令代表拷贝和粘贴，可以理解为 CopyTo。它需要两个参数，一个范围代表拷贝哪个范围的文本，一个位置，代表要将拷贝的内容放置在哪个位置。它的形式如下:
  :range-t-address
  # 第一个range 代表的是范围，要将哪个范围内的文本进行粘贴，第二个address 代表的是一个行号，要将粘贴的内容放置到哪个位置
  :1,4t7 # 把1-4行的内容复制到第7行
  ```
  
  
  | 命令                                           | 简写 | 用途                                                 |
  | ---------------------------------------------- | ---- | ---------------------------------------------------- |
  | :[range]delete [x]                             | d    | 删除指定范围内的行[到寄存器 x 中]                    |
  | :[range]yank [x]                               | y    | 复制指定范围的行[到寄存器 x 中]                      |
  | :[line]put [x]                                 | pu   | 在指定行后粘贴寄存器 x 中的内容                      |
  | :[range]copy                                   | t    | 把指定范围内的行拷贝到 {address} 所指定的行之下      |
  | :[range]move                                   | m    | 把指定范围内的行移动到 {address} 所指定的行之下      |
  | :[range]join                                   | j    | 连接指定范围内的行                                   |
  | :[range]normal                                 | narm | 对指定范围内的每一行执行普通模式命令                 |
  | :[range]substitute/{pattern}/ {string}/[flags] | s    | 把指定范围内出现{pattern}的地方替换为                |
  | :[range]global/{pattern}/[cmd]                 | g    | 对指定范围内匹配{pattern}的所有行，在其上执行Ex 命令 |

  - 有些命令暂时还不知道怎么用，不着急，后面说到对应部分，自然会提到的

- 范围符号

  | 符号 | 用途                         |
  | ---- | ---------------------------- |
  | `.`  | 当前行                       |
  | `$`  | 文件末尾                     |
  | `0`  | 虚拟行，位于文件第一行的上方 |
  | `1`  | 文件第一行                   |
  | `'m` | 包含标记m的行                |
  | `<`  | 高亮选区的起始行             |
  | `>`  | 高亮选区的结尾行             |
  | `%`  | 整个文件，相当于 `:1,$`      |


- 移动

  ```shell
  # 使用m命令，移动(交换位置)
  
  :range-m-address
  # 第一个range 代表的是范围，要将哪个范围内的文本进行粘贴，第二个address 代表的是一个行号，要将粘贴的内容放置到哪个位置
  
  :7m5  # 第7行和第五行的位置互换
  :.+2,$m.  # 当前位置偏移两行到末尾的内容与当前位置的内容互换
  ```

  

## 2. 查找

```shell
# 从当前位置开始
/string  # 正向查找string
?string  # 反向查找string
/word  # 查找word 
n  # 查找下一个（开始查找后直接输入）
:set hls  # 查找到的字符串高亮显示
*  # 将当前光标处的单词高亮显示，使用n浏览下一个查找高亮的结果

# 当光标处于目标单词的时候
*  # 直接进行搜索。
```

- 执行前预览第一处匹配

  ```shell
  vim模式并未开启这个效果，可以使用 incsearch 来激活这一效果。而neovim则默认支持这一选项。
  ```

  

- 将光标移动到匹配的结尾

  ```shell
  # 结尾处添加
  /e  # 让vim将光标移动到匹配字符串的结尾处
  ```

- 调整大小写敏感

  ```shell
  set ignorecase
  ```

  ```shell
  # 只有在输入的字符中有大写才启用大小写敏感，否则就是大小写不敏感。
  set smartcase
  ```

  - 输入

    ```shell
    当然我们也可以在每次搜索的时候单独指定本次搜索是否大小写敏感。可以在匹配时输入\c来不区分大小写而使用 \C区分大小写，这个符号可以出现在任何位置，哪怕你输入 /requ\Cire它也能正确找到所有的 require字符串。
    ```

- 使用正则表达式匹配

  vim支持正则表达式的搜索，vim采用的是 POXIS的正则表达式的规则，这就让我们一些习惯 Perl正则表达式规则的人在使用时会出现一些不适宜。现在我们来看一个具体的例子

  假设现在有一个 css 文件, 我需要搜索里面的16进制颜色

  body { color: #3c3c3c; } 
  a { color: #0000EE; } 
  strong { color: #000; }
  我们在搜索时输入这样一个正则表达式 `#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})` 。发现它会报错，但是正则表达式来看，这么写是没问题的，我们要匹配的是以 # 开头，后面有6个或者3个16进制数的字符。

  - 这是因为里面有特殊字符，需要进行转义，例如 () 在 vim 中有特殊用途,我们将在接下来介绍它的用途。我们需要将正则表达式写成这样` #\([0-9a-fA-F]\{6\}\|[0-9a-fA-F]\{3\}\)`
  
  - 好在vim提供了 `very magic` 模式，即除了 `_` 、 数字、字母之外的所有字符都具有特殊含义，这样我们就不用纠结哪些需要转义，哪些不需要了。可以在搜索的开头添加 `\v` 来启用这一模式，即我们可以输入 `\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})`
  
  - 我们还可以使用 `\x` 表示16进制数，以便简化上述正则表达式, `\v#(\x{6}|\x{3})`。
  
    `\x` 是vim 字符类中的一个成员，我认为比较有用的还有如下这些
  
    | 字符 | 含义                  |
    | :--- | :-------------------- |
    | \x   | 十六进制数            |
    | \X   | 非十六进制数          |
    | \d   | 数字                  |
    | \D   | 非数字                |
    | \o   | 八进制数              |
    | \o   | 非八进制数            |
    | \w   | 包括字母、数字和 _    |
    | \W   | 不包括 字母、数字和 _ |
    | \h   | 包括 字母和 _         |
    | \H   | 不包括字母和 _        |
    | \l   | 小写字母              |
    | \L   | 非小写字母            |
    | \u   | 大写字母              |
    | \U   | 非大写字母            |

- 除了有 very magic模式，vim 中还有 very nomagic 模式，在该模式中所有的字符都只表示它自身，没有特殊含义，例如 . 在正则表达中表示单个字符，但是在 very nomagic 模式中它就表示一个点，它可以匹配点这个字符本身，要启用 very nomagic 模式，可以使用 \V 作为前缀。

  使用括号获取子匹配项

  在 vim 中可以使用 <(\w+)\_s+\1> 来匹配重复单词，例如

  I love python
  python is so good
  这句话中我们可以匹配到 python 这个单词。

## 跨文件搜索

- grep 命令
  vim 中也提供了 :grep 命令，它是对 shell 中 grep 的封装。它可以让我们直接在vim中使用grep并且可以在vim中显示结果（当然我们也可以在命令模式中使用 :!grep 来调用shell的 grep 命令）。

  我们仍然以前面介绍的搜索 TODO 标签为例。
  我们先在 shell 中使用 grep 命令。

- 遍历 quickfix 列表
  quickfix 列表是由我们执行 :make 命令或者 :grep 命令所产生的，它会保存一个或者多个文件位置信息。我们可以使用以 c 开头的一组命令来遍历，下面列举出相关的命令：

  cnext：跳转到下一项
  cprev：跳转到上一项
  cfirst：跳转到第一项
  clast：跳转到最后一项
  cnfile：跳转到下一个文件的第一项
  cpfile：跳转到上一个文件的第一项
  cc n：跳转到第你项
  copen：打开 quickfix列表
  cclose: 关闭 quickfix列表
  后续使用 vim 时会大量使用到 quickfix 列表，为了减轻输入的负担，可以考虑将其定义为快捷键。

  :cnext 和 :cprev 命令前面可以加数字表示向后或者向前跳转多少次。例如我这里使用 :2cnext 表示向后跳转2次。

## 补全

- 自定义补全项来源
  默认情况下，vim 补全项主要来源于以下几个地方：

  缓冲区列表：vim补全项最基本的来源就是当前的缓冲区列表。它可以通过 <Ctrl - x><Ctrl - n> 来触发该项。
  包含文件，所有的编程语言都有包含文件的概念，例如 c/c++中的 #include , python 中的 import 。使用 <Ctrl-x><Ctrl-i> 可以触发这个选项，让vim从被包含文件中提取补全项。vim本身使用 c 语言编写的，它能够识别 c/c++ 语言中的关键字，我们可以指定 include 项来使 vim认识其他不同的关键字。一般常用的编程语言 vim 都能够识别，因此不需要修改 include 项。
  标签文件，我们使用 ctags 或者类似的插件的时候会生成一个标签文件，该文件会将扫描到代码中的关键字、函数、变量等的索引放入到一个文件中以供后续进行跳转。同时他们也会产生一系列的补全项到补全列表中。可以使用 <Ctrl+x><Ctrl+]> 来触发
  一般直接使用 <Ctrl + n> 触发的是当前缓冲区列表中的补全项，使用 <Ctrl+x> 作为前缀，可以触发其他类型的补全项。这么做有一个好处是尽量精简补全列表，减少了我们手动遍历的过程。但是有时候我们并不知道我想要的内容该从哪里来，有没有什么办法能做到，用 <Ctrl + n> 这个按钮就可以调用其他所有来源的补全项呢？

  要做到这点，可以使用 complete 这个配置项。该项包含一组由逗号分隔的单个字符表示的参数，当参数出现时表示需要扫描该参数代表的位置。使用 set complete? 可以看到，缺省项为 complete=.,w,b,u,t 。我们可以使用 set complete-=i 或者 set complete+=k 来删除或者添加某个扫描位置。常见的位置参数如下所示：

  . : 表示当前以打开的缓冲区
  w : 当前打开的窗口
  b : 当前缓冲区列表
  u : 当前处于缓冲区列表中，但是未打开的缓冲区
  t : 当前标签文件
  U : 当前打开的，不属于缓冲区列表中的缓冲区
  k : 从字典文件中加载的补全项
  i : 从当前文件和包含文件中读取
  d : 从当前文件和包含文件中读取使用 define定义的宏
  完整的内容可以使用 :h 'complete' 来查看。

  使用字典文件
  在上面的论述中，我们可以知道 vim 是可以自定义补全的字典文件，然后从字典中产生匹配的。我们可以使用 <Ctrl-x><Ctrl-k> 来加载字典中的匹配项。

  我们可以使用 set spell来启动拼写检查，拼写检查也会产生新的字典文件。如果不想使用该项，也可以使用 set dictionary来指定含有一个或者多个单词的字典文件。

  在这个例子中我们在 nvim-config 目录中新建一个 spell.txt 文件，我们在里面写入如下内容

  require
  return
  request
  然后使用 set dictionary=./spell.txt ，接着删除 init.lua 中的 return ，输入 re 然后使用 <Ctrl+x><Ctrl+k> 这个时候我们发现它已经加载了

- 补全整行
除了补全单词，vim还可以补全整行的内容，使用 <Ctrl+x><Ctrl+l> 可以触发补全整行的操作。
补全行的补全项来源与补全单词相同，需要注意的是补全行的操作会自动忽略行首的缩进。

- 补全文件名
在 shell中输入命令可以使用 <Tab> 键来自动补全文件路径，vim中使用 <Ctrl+x><Ctrl+f> 来对文件路径和文件名进行补全。

需要注意的是当我们使用相对路径来补全文件名时，使用的是工作目录，也就是你从哪个目录中进入的vim。我们可以在 vim中使用:cd来切换工作目录。例如我在 nvim-config这个工程的根目录执行 nvim init.lua，我们在这个文件中希望快速补全 basic/settings.lua这项，我们发现它在补全的时候报错

- 根据具体编程语言生成补全
上述补全在编辑普通文本的时候显的有点用处，但是作为程序员平时在写代码如果只能使用上述方式进行补全肯定会抓狂的。好在vim 提供了像其他IDE那样的基于编程语言的补全方式。使用该补全方式的快捷键为 <Ctrl+x><Ctrl+o> 要启用该方式，需要启动文件类型识别。

nvim 中已经启用了这一特性，因此不必特意进行设置，但是这里我还是给出它的配置。

vim.o.filetype="plugin"
或者vim中可以使用如下代码

set filetype=plugin
set nocompatiable # 设置与vi 不兼容
例如我们可以尝试着在 css 文件中使用补全

## 3. 替换

```shell
:%s/old/new/g  # 把全局的字符串old替换为new，（%所有行，old旧，new新，g行内）

:s/old/new  # 将当前行的第一个字符串old替换为new
:s/old/new/g  # 将当前行的所有字符串old替换为new
:90s/old/new/g  # 将指定行的所有字符串old替换为new
:90,93s/old/new/g  # 将指定范围的行的所有字符串old替换为new
:%s/old/new/g  # 将文本中所有的字符串old替换为new
:%s/old/new/gc  # 依次替换每个字符串关键字
:%s/^struct/int/g  # 将所有以struct开头的字符串替换为int
```

- 标志位
  上面的例子中我们使用了一个 g 作为标志位，其实还有其他的标志位。我们可以通过标志位灵活的定义 substitute 的行为。下面是一些常用的标志位：

  \r：插入一个换行符
  \t：插入一个制表符
  \\：插入一个反斜杠
  \1：插入第一个子匹配项
  \2：插入第二个子匹配项
  \0：插入匹配模式的所有内容
  &：与 \0用法相同
  ~：使用上一次调用 substitute时提供的 string内容
  \={vim script}：执行 vim script并将返回内容作为 string

- 手动选择是否需要替换

  其实不光yn这两个选项，从vim的提示看总共有 ynaql和 <Ctrl +e>以及 <Ctrl + y>。它们的含义如下：

  y：替换本处匹配
  n：不替换本处匹配
  a：替换此处之后的所有匹配项，随后退出本次替换
  q：退出本次匹配
  l：替换此处之后退出本次替换
  <Ctrl + e>：向上翻滚屏幕
  <Ctrl + y>：向下翻滚屏幕

## 4. 文件操作

```shell
:wq  # 保存退出（文件已经被修改，保存修改并退出）
:x   # 仅需要保存时保存
:qa!  # 强行退出所有的正在编辑的文件，就算别的文件有更改。
:w  # 仅保存
ZZ  # 保存，不需要按回车和换行   

:q!  # 强制退出，不保存（文件已经被修改，放弃修改退出）
:q  # 仅退出（若文件没有修改，直接退出）
:e!  # 放弃修改，重新回到文件打开时的状态

:U  # 恢复一整行原来的面貌（文件打开时的文本状态）
u  # 撤销上一步的操作。
<Ctrl-r>  # 将原来的插销重做一遍

:pwd  # 查看当前vim的工作目录是哪个，一般来说我们是从shell中的哪一个目录中进入的vim，那么vim的工作目录就是哪个。
:edit {filename} (或者简写为 :e )  # 打开一个文件。
# 如果filename采用绝对路径，那么打开的就是绝对路径所对应的文件，如果是相对路径，那么就可以打开相对与vim工作目录的文件。vim的命令模式是支持自动补全的，我们可以通过tab来快速补全路径

vim 在命令行中提供了一个% 作为活动缓冲区的完整路径。我们在直接介绍命令模式的时候，
%  # 是作为范围表示当前打开的整个文本。这里它作为路径参数的话，表示的是当前打开文本的完整路径。

:edit %<Tab>  # 自动显示整个路径

:edit %:h<Tab>  # 自动出现对应的目录。自动去掉文件名，直接定位到对应的目录

# 操作系统中，有一个PATH 环境变量，输入命令的时候，他会在PATH 所指定的目录中查找对应命令。vim中也有类似的概念。

:find  # 根据输入的文件名打开文件。但是使用:find 的前提是配置path 变量。它们合作完成打开文件的操作，与环境变量的用法类似。
:set path+=./**  # 将当前工作目录以及它下面的所有子目录作为path变量。然后可以直接输入:find keybinds.lua 打开这个文件了。
# find会打开当前文件所在目录附近的同名文件。可以在输入完文件名之后，按下<Tab> 它会提示所有匹配到的文件。我们可以指定位置的文件打开。






```

-  目录管理

  ```shell
  :edit ./dir  # 当前已经打开了一个文件，想再继续显示这个目录
  
  :Explore  # 专门用来显示目录结构。它可以简写为:E 后面不加任何东西可以打开当前文件所在目录，也可以加上路径打开指定目录。
  
  :Sexplore  # 水平方向打开目录
  :Vexplore  # 竖直方向打开目录。
  
  # vim自带的这个目录管理工具最大的问题是我通过回车键从里面选择一个之后，会在当前窗口打开一个新的缓冲区，并且把目录树给覆盖了，这个时候我们可以快速按下<Ctrl + Shift>^ 来在新打开的缓冲区和目录树之间切换。
  # 除了浏览目录结构以外，也可以利用该插件进行文件和目录的创建、删除、修改、重命名等操作，例如，使用% 来创建文件, d 来创建目录，R 重命名或者移动目录和文件，使用 D 来删除一个目录或者文件
  
  # 我们在原项目的基础之上打开一个新的有不存在目录的文件，例如:e random/111/test.txt。可以进入了vim的编辑界面，也可以进行编辑，但是一旦执行写命令的时候，发现vim会提示目录不存在。它保存文件需要将文件保存到一个已经存在的目录中。
  :w 
  :!mkdir -p random/111  # 创建对应目录，然后再执行写入。或者可以灵活的使用在前面介绍的:%h 来快速补全相对路径
  
  ```

  

- 强制以root用户写入文件

  ```shell
  有时候我们使用vim打开了系统文件，例如打开了/etc/hosts 文件，但是保存的时候意识到忘了加sudo 了，导致无法写入，我以前的办法是先退出，然后再用root权限打开，这样就导致之前输入的内容全都丢失了，幸亏我养成了前面说的那个习惯，打开文件之后的第一步就是执行:w,在学习了vim的命令模式之后，估计各位小伙伴已经有思路来解决这个问题了。
  
  我们以当前文件内容作为命令输入，配合shell命令，完成。我们知道可以使用tee 来将输入内容写入文件中。那么我们的命令可以是 :w !sudo tee % > /dev/null, 我们使用:w 来指定当前缓冲区的内容作为shell命令的输入。然后配合tee 来将内容写入到% 也就是当前文件。
  ```

  

## 缓冲区
```shell
:ls  # 查看当前打开的缓冲区
#第一列的数字代表缓冲区的编号，该编号由vim随机指定，第二列的%a代表缓冲区为激活的缓冲区(active)当前窗口显示的内容为激活缓冲区的内容。第三列则是缓冲区的名称，一般vim会将文件名作为缓冲区的名称

:bnext  # 以:ls 的显示顺序，显示下一个缓冲区
:bprev  # 显示上一个缓冲区
:blast  # 显示最后一个缓冲区
:bfirst  # 显示第一个缓冲区

# 在切换过缓冲区之后再次执行:ls 之后发现此时显示的内容已有一些变化。
# 除了%a 代表当前处于激活状态的缓冲区外，另外一个缓冲区的前面多了个#h ，# 代表上一次处于激活状态的缓冲区，我们可以使用<ctrl-^> 来切换到上次处于激活状态的缓冲区。而h 则代表隐藏缓冲区，当一个缓冲区由激活状态变为非激活状态的时候，vim会将其标记为隐藏缓冲区。

#除了按照顺序显示缓冲区，还可以通过缓冲区名称或者序号来指定显示某个缓冲区。
:buffer 1  # 显示编号为1的缓冲区。

#还可以更直观的使用buffer {bufname} 来显示指定缓冲区，其中{bufname} 代表的是缓冲区的名称,例如
:buffer test.py

# 删除缓冲区
:bdelete {bufname}  # 删除某个缓冲区
# 该命令支持前面几篇文章中提到的范围操作
:nstart, nend bdelete  # 来删除编号nstart 到 nend 的所有缓冲区。

```
- 缓冲区列表参数
	```shell
	使用 :args 显示参数列表。
	其中使用[] 包裹起来的是当前处于激活状态也就是当前窗口显示的的缓冲。注意请不要被这个名字迷惑了，它并不是传递给vim的参数，而是作为参数传递给vim的文件的列表。也就是这条命令所打开的文件的列表。本质上仍然是一个缓冲区列表
	除了使用:args查看参数列表，也可以在:args 命令后添加缓冲区名称，例如:args init.lua 这样就将一个新的文件纳入之前的缓冲区列表中进行管理。
	至也可以在后面添加shell命令，以shell命令的输出作为缓冲区列表的参数，添加到参数列表，它的形式为
	:args `cmd`
	
	:args :ls
	上述事例中，我们通过args 来将ls 输出的结果作为参数列表。再通过:ls 命令查看一下当前缓冲区列表，发现之前打开的仍然存在，只是我们将test.py 和 init.lua 这两个文件形成一组作为缓冲区的参数列表。
	
	当我们指定好了一组缓冲区列表参数之后，可以使用:next 、 :prev 、first、last 在这组缓冲区列表中进行切换。
	
	:args 命令本身也支持使用通配符来将所有匹配的文件名设置为缓冲区列表参数，例如:args *.py 将当前目录中所有py文件加入，或者使用:args **/*.py 来将当前目录下所有子目录中的py文件加入。一般来说使用shell命令或者使用通配符的方式居多，但是也有直接使用文件名的情况出现
	

- 参数

  ```shell
  bnext: 切换到缓冲区列表中的下一个缓冲区
  bprev: 切换到缓冲区列表中的下一个缓冲区
  blast: 切换到缓冲区列表中的最后一个缓冲区
  bfirst: 切换到缓冲区列表中的第一个缓冲区
  <Ctrl+^>: 在上一个被激活的缓冲区和当前被激活的缓冲区之间进行轮换
  args: 显示当前缓冲区列表参数。后面也可以跟上文件名、shell命令和通配符，设置对应的缓冲区列表参数
  next: 切换到缓冲区列表参数中的下一个缓冲区
  prev: 切换到缓冲区列表参数中的上一个缓冲区
  last: 切换到缓冲区列表参数中的最后一个缓冲区
  first: 切换到缓冲区列表参数中的第一个缓冲区
  ```

- 退出

  ```shell
  我们随便打开多个文件，在任意一个或者多个缓冲区中执行o 或者其他能另其修改的命令。然后执行切换缓冲区的命令，例如:bnext 之类的，切换之后再次执行:ls
  
    1 #h + ".\init.lua"                   line 2
    2 %a   ".\test.py"                    line 1
  我们发现在之前的基础之上，多了一个 + 它代表着这个缓冲区上的修改并未同步到磁盘文件中。此时如果执行:q 进行退出的话，会提示当前有缓冲区未同步到文件中，并且跳转到未同步的缓冲区。我们可以执行:w 来写入将缓冲区内容磁盘，也可以使用:q! 来忽略该缓冲区的修改，或者使用:edit!来强行的从磁盘读取内容并覆盖本次修改。这个时候vim将会切换到下一个未保存的缓冲区。如果嫌每次都这样比较麻烦，可以执行:qall! 忽略所有未修改的缓冲区并退出，或者使用:wall 来写入所有修改。
  
  
  ```


## 寄存器

- 无名寄存器
  ```shell
  在之前介绍过，可以使用d来删除一段内容，使用p来粘贴，使用y来复制， vim中其他的带有删除功能的operator 像 x、c、s 之类的，vim在删除之前会将被删除内容先放到无名寄存器中，然后执行删除操作。严格意义上来说，他们并不是删除而是剪切。后续可以通过p 命令来粘贴之前被删除的内容
  无名寄存器有一个专用的符号，使用 "来表示。也就是说dd 命令其实等效为 ""dd。但是为了偷懒和方便，还是少输几个字符的好。
  ```

- 有名寄存器

  ```shell
  # 它是对应无名寄存器来说的，无名寄存器虽然说使用方便，但是有一个很大的问题，那就是如果我们连续两次执行了删除或者复制操作，那么前一次保存的内容将会被后一次的给覆盖掉。为了解决这个问题，一个思路就是使用有名寄存器。
  vim中提供了由a到z的有名寄存器，可以在使用operator 的操作前面指定需要使用的寄存器 
  "-寄存器名的格式  # 引用一个寄存器
  
  "-regester-operator-motion
  例如在执行删除的时候 
  "add  # 将一行删除的内容放到a寄存器中
  "bdd  # 将一行删除的内容放到b寄存器中，
  # 执行粘贴的时候，可以用
  "ap  # 使用a寄存器的内容
  "bp  # 使用b寄存器的内容
  ```

- 复制寄存器

  ```shell
  复制寄存器使用 0 来表示
  "0p  # 将复制寄存器的内容取出
  :reg 0  # 查看这个寄存器的内容
  ```

- 黑洞寄存器

  ```shell
  前面说到 dd会将被删除内容放入到无名寄存器中，如果这段内容我确实不想要了，也不想它占用寄存器，有没有什么办法彻底删除呢，答案是使用黑洞寄存器，顾名思义，放入该寄存器中的内容都被吸走丢失了，无法使用了。
  黑洞寄存器使用 _作为标识符，执行删除指令的时候可以使用 "_dd这样就再也访问不到之前删除的内容了。
  ```

- 系统剪切板

  ```shell
  vim可以使用+来访问系统剪切板。
  # 例如 
  "+yy  # 将内容复制到系统剪切板中，供其他程序使用。
  ```

- 表达式寄存器

  ```shell
  前面介绍的几种寄存器都是被动的存储静态的内容，只有存储功能。表达式寄存器则可以接受一段vim脚本并执行它并输出结果。表达式寄存器使用 =来表示。
  例如在插入模式中可以使用 <Ctrl+r>=6*6 来进行数学计算并输出。
  ```

  根据之前的惯例，大写字母与小写字母都可以使用，大写字母的功能比小写字母要强，例如大写的标签标示全局，小写的只能用于单个文件。这里大写的寄存器与小写的寄存器是同一个寄存器，使用大写时我们可以对寄存器内容进行追加操作。




## 5. 编辑多个文件

> 文件和缓冲区的区别
> 文件是保存在磁盘上的，而打开的文件的文件是在内存中，在内存中有一个缓冲区，用来存放打开的文件。
>
> vim每次打开文件时都会创建一个缓冲区，vim支持打开多个文件

```shell
:ls   # 查看缓冲区列表
:buffers  # 查看缓冲区列表
:buffer N  # 根据缓冲区列表的编号跳转到指定缓冲区
:bnext/bprev  # 遍历缓冲区列表
:bfirst/blast  # 分别调到缓冲区列表的开头和结尾
:write  # 将缓冲区的修改保存到磁盘上
:edit! e!  # 放弃缓冲区的修改，恢复到文件打开时的状态
:edit file  # 编辑另一个文件
:wnext  # 保存当前缓冲区的修改并跳转到缓冲区列表中的下一个文件
:set autowrite
```


## 6. 文件切换

> 同时打开多个文件的状态下

```shell
:bn  # 切换下一个文件
:bp  # 切换上一个文件（陈皓注：我喜欢使用:n到下一个文件）
:n  # 切换上一个文件
```



## 7. 标签页与折叠栏

```shell
:tabedit {filename}  # 打开一个新的标签页，如果不加文件名则打开一个空的标签页。也可以使用tabnew 命令，参数与效果完全相同。
:<ctrl-w>T  # 将当前缓冲区移动到新的标签页中
:tabc[lose]  # 关闭当前标签页
:tabo[nly]  # 后者是关闭所有，只保留当前激活的标签页

# 切换标签页
# 在普通模式下使用
gt  # 切换到下一个标签页,支持添加数字编号，，编号从1开始
gT  # 切换到上一个标签页，

# 在命令模式中
:tabn[ext]  # 切换到下一个标签页,支持添加数字编号，编号从1开始
tabp[revious]  # 切换到上一个标签页，

:tabmove {n}  # 用来移动当前标签页到指定位置，后面加数字表示移动到第几个标签的位置，不加数字默认移动到结尾位置。

标签页的新建：tabedit file/tab split
标签页的切换: tabn/tabp
按键：gt/gT
标签页的关闭
    tabclose 
关闭当前的标签页: tabonly
创建一个折叠
    zf200G:将光标和200行之间的代码折叠起来
折叠的打开与关闭
    za:  打开和关闭折叠
    zr/zm: 一层一层地打开和关闭折叠
    zR/zM: 分别打开和关闭所有的折叠
折叠键的光标移动
    zj: 跳转到下一个折叠处
    zk: 跳转到上一个折叠处
删除折叠
    zd: 删除光标下的折叠
    zD: 删除光标下的折叠以及嵌套的折叠
    zE: 删除所有的折叠标签
    创建的折叠当退出vim之后就失效了
```



## 8. 多窗口操作

```shell
:split/vsplit filename  # 分割窗口

ctrl+w hjkl  # 窗口间跳转
ctrl+w w  # 窗口间跳转

ctrl+w HJKL  # 移动窗口

# 调整窗口尺寸
ctrl+w +/-  # 调整窗口的高度
ctrl+w </>  # 调整窗口的宽度
ctrl+w =  # 所有的窗口设置相同的尺寸
:resize n  # 将当前窗口尺寸调整为N行

# 关闭窗口
:close 关闭一个窗口  
:close!  # 强制关闭
:qall  # 退出所有窗口
:qall!  # 放弃修改，退出所有窗口
:wqall  # 保存并退出所有窗口
:wall  # 保存所有窗口
```



## vim显示

- vim中有一个`wrap` 设置，表示一行文本超过多少行就会自动折行，这样就不会出现在一个屏幕上显示不全的问题了。

  

# 六、显示帮助

```shell
:help h 显示h的帮助信息

:help
```

> 退出时需要使用:q

```shell
自动提示： <Ctrl-n> 和 <Ctrl-p>
在 Insert 模式下，你可以输入一个词的开头，然后按 <Ctrl-p>或是<Ctrl-n>，自动补齐功能就出现了……

```






# 七、使用技巧

| 命令          | 说明                                  |
| ------------- | ------------------------------------- |
| %             | 自动匹配括号[]{}()                    |
| ____*         | 查找光标处的单词                      |
| :find         | 搜索文件                              |
| gd            | 高亮显示所有相同单词                  |
| =             | 格式化选中的代码（相当于ident）       |
| Ctrl-v        | 选中多列并且对多列文本同时编辑        |
| Ctrl-p        | 自动补齐。请查看帮助文档omni-complete |
| xp            | 交换两个字母的顺序                    |
| :TOhtml       | 把当前文件转换为html文件              |
| dd            | 删除当前行                            |
| :buf filename | 通过buffer名字来切换buffer            |

- 填充100个数

  ```shell
  :put=range(1,5)  # 生成1-5的升序数字
  :put=range(10,0,-1)  # 生成1-10的降序数字
  :put=range(0,10,2)  # 从 0 到 10 递增 2
  :put=range(5)  # 从0开始，上升到5
  :put=range(line(','),50)  # 在 vim 中，显示当前行，我们可以使用 line('.')。假设您当前位于第 40 行。要生成第 50 行的数字
  ```

- 删除文本

  ```shell
  # 范围删除
  :[start],[end]d
  .  # 点，当前行
  $  # 最后一行
  %  # 所有行
  
  :.,$d  # 从当前行到文件末尾
  :.,1d  # 从当前行到文件开头
  :10,$d  # 从第十行到文件末尾
  :0,%d
  # 删除全部文本
  ggdG
  
  # 删除多行
  5dd  # 删除光标后的五行
  5jd
  ```

- 递增数字或字母

  ```shell
  <Ctrl-v>  10j g <Ctrl-a>  # 选中10行，递增
  ```

  

- 使用寄存器快速复制

  ```shell
  ################################## 示例1：复制粘贴的使用
  
  假设我们要将如下代码
  
  print("hello world")
  print("hello vim")
  修改为
  
  print("hello world")
  print("hello world")
  
  可以在第一行使用 yi"来复制引号内的内容，但是如果在第二行先使用 ci"再使用 p进行粘贴的话会发现粘贴的仍然是hello vim这是因为后面使用c操作的时候，已经将原来的给覆盖掉了。现在我们来解决这个问题。
  
  第一种解法：y指令可以额外产生一个动作，它会将内容放入到复制寄存器中，那么在执行了ci"之后使用 "0p来使用复制寄存器中的内容
  第二种解法：可以手动指定ci"删除的内容放入到黑洞寄存器中，即执行"_ci"这样就不会产生覆盖问题。
  前两种方法虽然解决问题了，但是都引入了新的寄存器，按键比较繁琐，如果不想引入新寄存器，就得使用接下来介绍的第三种方法了，它也是我最喜欢的方法了。
  
  解法三：由于我们需要先删除之前的内容再复制，为了快速删除，所以会发生覆盖问题，我们只要不执行删除操作就不会覆盖了，为了一次性完成粘贴替换的操作，可以使用选择模式，之前介绍选择模式的时候说过，在选择模式下operator 会将选中部分作为操作区域。可以使用 vi" 来选中引号内容，然后直接使用 p 完成复制
  
  
  ##################################### 示例2：插入模式中使用寄存器
  
  之前已经在介绍表达式寄存器的时候已经介绍了如何在插入模式中使用寄存器，可以使用 <Ctrl + r> + register 例如上面的例子可以使用 <Ctrl + r>0来将复制寄存器中的内容写入到光标所在位置。
  
  相比上面介绍的前两种解法，它省去了切换回普通模式的步骤，相对来说更高效一点。但是我觉得它还是比不上第三种解法。
  
  ##################################### 示例三： 处理粘贴混乱的问题
  
  有的时候在粘贴代码的时候发现代码的格式可能会乱，这个时候可以设置 :set paste选项，设置之后复制粘贴将不再出现这个问题，但是它会使我们在其他模式下设置的快捷键失效，在粘贴完了之后可以使用 :set nopaste取消该设置。由于我使用的neovim中没有发现这个问题，就不演示了，各位使用vim的小伙伴可以自行测试。
  
  当然处理该问题的另一种方式是使用之前介绍的在vim中使用剪切板的方法，也就是使用 "+p这样的形式。
  ```

  

# 八、Vim解释





- 单词和字串
  - Vim有单词（word）和字串（WORD）两种概念。
    word是指由iskeyword选项定义的字符串；
    WORD则是指用空白符分隔的字符串。
- 区别单词应该以字母、数字、其他非空白字符进行分类
- 字串仅仅以空白字符为区分
- 同一类型的字符序列组成的部分作为一个单词。可以使用`:help word`和`:help WORD`命令，查看更多帮助信息。

按照通常的定义，单词是一系列字母的组合。然而在C程序中，则认为字母、数字和下划线来组成一个单词，比如size56就会被认为是一个单词。但是在LISP程序中，可以在变量名中使用-，这时会认为total-size是一个单词，而在C程序中这却会被认为是两个单词。那么如何来解决这些定义的差异呢？

vim的解决方案：

```shell
定义哪些是一个单词的，而哪些又不是。
:set iskeyword=specification

查看当前选项，可以使用下面的命令：
:set iskeyword?

命令会返回一组用逗号分隔的值（以下是在Windows下的默认值）：
iskeyword=@,48-57,_,192_255

如果我们想要单词中的字母是专一的元音，可以使用以下命令：
:set iskeyword=a,e,i,o,u

我们还可以使用横线来指定字母的范围。如果要指定所有的小写字母，可以用下面的命令：
:set iskeyword=a-z

对于那些不能直接指定的字符，可以使用十进制的数字来表示。如果我们要指定小写字母和下划线为一个单词，可以使用下面的命令：
:set iskeyword=a-z,45

排除某一个字符，可以在这个字符前加上一个前缀^。例如我们可以定义一个单词由除了q以外的小写字符组成：
:set iskeyword=@,^q

iskeyword（命令iskeyword可以简记为isk）选项使用以下特殊字符：

a	  # 字符a
a-z	  # 所有由a到z的字符
@	  # 由函数isalpha()所定义的所有字符
@-@	  # 字符@
^x	  # 除了x以外的字符
^a-c	  #除了a到c以外的字符

:help iskeyword  # 查看更多帮助信息。
```



- 所谓blank字符就是空格，tab，换行，回车等









# 九、实用配置文件

- `vim $HOME/.vimrc` 编辑配置文件

```shell
syntax on
set expandtab #显示选项卡
set autoindent #自动缩进
set number #显示行号
set relativenumber    #显示相对行号                   
```

```shell
"==================="
"1.基本设置"
"==================="
set wildmenu"按TAB键时命令行自动补齐"
set ignorecase"忽略大小写"
set number "显示行号"
set visualbell"禁止响铃"
set ruler"显示当前光标位置"
set autoread"文件在Vim之外修改过，自动重新读入"
set autowrite"设置自动保存内容"
set autochdir"当前目录随着被编辑文件的改变而改变"
set nocp "使用vim而非vi"
set mouse=a"开启鼠标支持"
map 9 $"通过9跳转到行末尾,0默认跳转到行首"
map <silent>  <C-A>  gg v G "Ctrl-A 选中所有内容"
filetype on "启动文件类型检查"
filetype plugin on "运行vim加载文件类型插件"

"==================="
"2.程序开发相关的设置"
"==================="
"(1)使用%来选择语句块，然后使用快捷键zf来折叠"
set foldmethod=marker
"(2)注释：选中文本后，输入;c即可注释，输入;u 即可取消注释"
vmap <silent> ;c :s/^/\/\//<CR>:noh<CR>
vmap <silent> ;u :s/\/\///<CR>:noh<CR>
"(3) 编译和运行程序的快捷键"
map <silent>  <C-F5> :make %:r <CR>:!./%:r<CR>  "Ctrl+F5: 执行makefile文件"
map <silent>  \rr :!gcc  -Wall -g  %  -lm -o  %:r<CR> :!./%:r<CR>"\rr: 编译并运行当前文件的对应程序"
map  <silent>  \rc :!gcc  -Wall -g -c % <CR>"\rc:编译当前文件"
"(4)源文件和头文件之间快速切换"
nmap ,a :find %:t:r. ",a: 切换到任意文件。需要手动输入文件的后缀"
nmap ,c :find %:t:r.c<cr> ",c: 切换到同名c语言的源文件"
nmap ,C :tabf %:t:r.cpp<cr> ",C: 切换到同名c++的源文件,以tabpage形式打开"
nmap ,h :find %:t:r.h<cr>",h 切换到当前文件对于的头文件"
"(5)其他"
syn on "开启语法高亮功能"
set pastetoggle=<F11> "F11来支持切换paste和nopaste状态。"

"============"
"3. 多窗口操作"
"============"
map + <C-W>+  "+：扩大窗口"
map - <C-W>-  "- :   缩小窗口"
map <C-l> <C-W>l "C-l 移动到右侧窗口"
map <C-h> <C-W>h "C-h 移动到左侧窗口"
map <C-j> <C-W>j   "C-j 移动到下方窗口"
map <C-k> <C-W>k "C-k 移动到上方窗口"

"============"
"4. tabpages切换"
"============"
map < :tabpre<CR> 
map > :tabnex<CR>

"============="
"5. 设置缩进"
"============="
set cindent "c/c++自动缩进"
set smartindent
set autoindent"参考上一行的缩进方式进行自动缩进"
filetype indent on "根据文件类型进行缩进"
set softtabstop=4 "4 character as a tab"
set shiftwidth=4
set smarttab 

"================="
"6. 当前文件内搜索选项"
"================="
set hlsearch "开启搜索结果的高亮显示"
set incsearch "边输入边搜索(实时搜索)"

"=============="
"7. 会话功能"
"=============="
autocmd VimLeave * :mksession! ~/.last.vim "保存当前会话"
autocmd VimEnter * :so ~/.last.vim "加载会话"

"=========================="
"8.不要交换文件和备份文件，减少冲突"
"=========================="
set noswapfile
set nobackup
set nowritebackup

"============="
"9. 查找和替换文本"
"============="
nmap ;s :%s/\<<C-R>=expand("<cword>")<CR>\>/
nmap ;g :vimgrep <C-R>=expand("<cword>")<CR>

"========================"
" 10.快捷文本输入"
"========================"
map <silent>  \d a<C-R>=strftime("%Y/%m/%d %A")<CR>  "快捷输入日期"
map <silent>  \t a<C-R>=strftime("%Y/%m/%d %H:%M:%S")<CR>"快捷输入时间"
map <silent>   ,d :split ~/Dropbox/Doc/ <CR> 
iab --l  -------------------- 
iab ==l  ====================

"========================"
"11.txt文件按照wiki语法高亮"
"========================"
 autocmd BufNewFile *.txt set ft=confluencewiki 
 autocmd BufEnter *.txt set ft=confluencewiki

 "======================"
 "12.设置文件编码，解决中文乱码问题"
 "======================"
 if has("multi_byte")
    set fileencodings=utf-8,ucs-bom,cp936,cp1250,big5,euc-jp,euc-kr,latin1
 else
    echoerr "Sorry, this version of (g)vim was not compiled with multi_byte"
 endif

 "==================="
 "13. 对gvim 的设置"
 "=================="
 if has("gui_running")
     colorscheme  morning
     set guifont=Monaco:h13
     set guioptions=mr "只显示菜单和右侧滚动条"
 endif

```

- 配置文件

```shell
"=========================================================================
"
"" DesCRiption: 适合自己使用的vimrc文件，for Linux/Windows, GUI/Console
"
""=========================================================================
syntax on "自动语法高亮
"winpos 5 5          " 设定窗口位置  
"set lines=40 columns=155    " 设定窗口大小  
"set nu              " 显示行号  
set go=             " 不要图形按钮  
"color asmanian2     " 设置背景主题  
set guifont=Courier_New:h10:cANSI   " 设置字体  
"syntax on           " 语法高亮  
"autocmd InsertLeave * se nocul  " 用浅色高亮当前行  
"autocmd InsertEnter * se cul    " 用浅色高亮当前行  
"set ruler           " 显示标尺  
set showcmd         " 输入的命令显示出来，看的清楚些  
"set cmdheight=1     " 命令行（在状态行下）的高度，设置为1  
"set whichwrap+=<,>,h,l   " 允许backspace和光标键跨越行边界(不建议)  
"set scrolloff=3     " 光标移动到buffer的顶部和底部时保持3行距离  
set novisualbell    " 不要闪烁(不明白)  
"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}   "状态行显示的内容  
"set laststatus=1    " 启动显示状态行(1),总是显示状态行(2)  
set foldenable      " 允许折叠  
set foldmethod=manual   " 手动折叠  
"set background=dark "背景使用黑色 
set nocompatible  "去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  
" 显示中文帮助
if version >= 603
    set helplang=cn
    set encoding=utf-8
endif
" 设置配色方案
"colorscheme murphy
"字体 
"if (has("gui_running")) 
"   set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 
"endif 


 
set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,cp936
set fileencoding=utf-8"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""新文件标题""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"新建.c,.h,.sh,.java文件，自动插入文件头 
autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec ":call SetTitle()" 
""定义函数SetTitle，自动插入文件头 
func SetTitle() 
    "如果文件类型为.sh文件 
    if &filetype == 'sh' 
        call setline(1,"\#########################################################################") 
        call append(line("."), "\# File Name: ".expand("%")) 
        call append(line(".")+1, "\# Author: 冷倾殇") 
        call append(line(".")+2, "\# mail: 1500428751@qq.com") 
        call append(line(".")+3, "\# Created Time: ".strftime("%c")) 
        call append(line(".")+4, "\#########################################################################") 
        call append(line(".")+5, "\#!/bin/bash") 
        call append(line(".")+6, "") 
    else 
        call setline(1, "/*************************************************************************") 
        call append(line("."), "    > File Name: ".expand("%")) 
        call append(line(".")+1, "    > Author: 冷倾殇") 
        call append(line(".")+2, "    > Mail: 1500428751@qq.com ") 
        call append(line(".")+3, "    > Created Time: ".strftime("%c")) 
        call append(line(".")+4, " ************************************************************************/") 
        call append(line(".")+5, "")
    endif
 "   if &filetype == 'cpp'
 "       call append(line(".")+6, "#include<iostream>")
 "       call append(line(".")+7, "using namespace std;")
 "       call append(line(".")+8, "")
 "   endif
 "   if &filetype == 'c'
 "       call append(line(".")+6, "#include<stdio.h>")
 "       call append(line(".")+7, "")
 "   endif
    "新建文件后，自动定位到文件末尾
    autocmd BufNewFile * normal G
endfunc 
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"键盘命令
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


nmap <leader>w :w!<cr>
nmap <leader>f :find<cr>


" 映射全选+复制 ctrl+a
map <C-A> ggVGY
map! <C-A> <Esc>ggVGY
map <F12> gg=G
" 选中状态下 Ctrl+c 复制
vmap <C-c> "+y
"去空行  
nnoremap <F2> :g/^\s*$/d<CR> 
"比较文件  
nnoremap <C-F2> :vert diffsplit 
"新建标签  
map <M-F2> :tabnew<CR>  
"列出当前目录文件  
map <F3> :tabnew .<CR>  
"打开树状文件目录  
map <C-F3> \be  
"C，C++ 按F5编译运行
map <F5> :call CompileRunGcc()<CR>
func! CompileRunGcc()
    exec "w"
    if &filetype == 'c'
        exec "!g++ % -o %<"
        exec "! ./%<"
    elseif &filetype == 'cpp'
        exec "!g++ % -o %<"
        exec "! ./%<"
    elseif &filetype == 'java' 
        exec "!javac %" 
        exec "!java %<"
    elseif &filetype == 'sh'
        :!./%
    endif
endfunc
"C,C++的调试
map <F8> :call Rungdb()<CR>
func! Rungdb()
    exec "w"
    exec "!g++ % -g -o %<"
    exec "!gdb ./%<"
endfunc
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""实用设置
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 设置当文件被改动时自动载入
set autoread
" quickfix模式
autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>
"代码补全 
set completeopt=preview,menu 
"允许插件  
filetype plugin on
"共享剪贴板  
set clipboard+=unnamed 
"从不备份  
set nobackup
"make 运行
:set makeprg=g++\ -Wall\ \ %
"自动保存
set autowrite
"set ruler                   " 打开状态栏标尺
set cursorline              " 突出显示当前行
set magic                   " 设置魔术
set guioptions-=T           " 隐藏工具栏
set guioptions-=m           " 隐藏菜单栏
"set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\
" 设置在状态行显示的信息
set foldcolumn=0
set foldmethod=indent 
set foldlevel=3 
set foldenable              " 开始折叠
" 不要使用vi的键盘模式，而是vim自己的
set nocompatible
" 语法高亮
set syntax=on
" 去掉输入错误的提示声音
set noeb
" 在处理未保存或只读文件的时候，弹出确认
set confirm
" 自动缩进
set autoindent
set cindent
" Tab键的宽度
set tabstop=4
" 统一缩进为4
set softtabstop=4
set shiftwidth=4
" 不要用空格代替制表符
set noexpandtab
" 在行和段开始处使用制表符
set smarttab
" 显示行号
set number
" 历史记录数
set history=1000
"禁止生成临时文件
set nobackup
set noswapfile
"搜索忽略大小写
set ignorecase
"搜索逐字符高亮
set hlsearch
set incsearch
"行内替换
set gdefault
"编码设置
set enc=utf-8
set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936
"语言设置
set langmenu=zh_CN.UTF-8
set helplang=cn
" 我的状态行显示的内容（包括文件类型和解码）
"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}
"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]
" 总是显示状态行
"set laststatus=2
" 命令行（在状态行下）的高度，默认为1，这里是2
set cmdheight=2
" 侦测文件类型
filetype on
" 载入文件类型插件
filetype plugin on
" 为特定文件类型载入相关缩进文件
filetype indent on
" 保存全局变量
set viminfo+=!
" 带有如下符号的单词不要被换行分割
set iskeyword+=_,$,@,%,#,-
" 字符间插入的像素行数目
set linespace=0
" 增强模式中的命令行自动完成操作
set wildmenu
" 使回格键（backspace）正常处理indent, eol, start等
set backspace=2
" 允许backspace和光标键跨越行边界
set whichwrap+=<,>,h,l
" 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）
set mouse=a
set selection=exclusive
set selectmode=mouse,key
" 通过使用: commands命令，告诉我们文件的哪一行被改变过
set report=0
" 在被分割的窗口间显示空白，便于阅读
set fillchars=vert:\ ,stl:\ ,stlnc:\
" 高亮显示匹配的括号
set showmatch
" 匹配括号高亮的时间（单位是十分之一秒）
set matchtime=1
" 光标移动到buffer的顶部和底部时保持3行距离
set scrolloff=3
" 为C程序提供自动缩进
set smartindent
" 高亮显示普通txt文件（需要txt.vim脚本）
au BufRead,BufNewFile *  setfiletype txt
"自动补全
:inoremap ( ()<ESC>i
:inoremap ) <c-r>=ClosePair(')')<CR>
:inoremap { {<CR>}<ESC>O
:inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
:inoremap " ""<ESC>i
:inoremap ' ''<ESC>i
function! ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction
filetype plugin indent on 
"打开文件类型检测, 加了这句才可以用智能补全
set completeopt=longest,menu
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CTags的设定  
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let Tlist_Sort_Type = "name"    " 按照名称排序  
let Tlist_Use_Right_Window = 1  " 在右侧显示窗口  
let Tlist_Compart_Format = 1    " 压缩方式  
let Tlist_Exist_OnlyWindow = 1  " 如果只有一个buffer，kill窗口也kill掉buffer  
let Tlist_File_Fold_Auto_Close = 0  " 不要关闭其他文件的tags  
let Tlist_Enable_Fold_Column = 0    " 不要显示折叠树  
autocmd FileType java set tags+=D:\tools\java\tags  
"autocmd FileType h,cpp,cc,c set tags+=D:\tools\cpp\tags  
"let Tlist_Show_One_File=1            "不同时显示多个文件的tag，只显示当前文件的
"设置tags  
set tags=tags  
"set autochdir 


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"其他东东
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"默认打开Taglist 
let Tlist_Auto_Open=1 
"""""""""""""""""""""""""""""" 
" Tag list (ctags) 
"""""""""""""""""""""""""""""""" 
let Tlist_Ctags_Cmd = '/usr/bin/ctags' 
let Tlist_Show_One_File = 1 "不同时显示多个文件的tag，只显示当前文件的 
let Tlist_Exit_OnlyWindow = 1 "如果taglist窗口是最后一个窗口，则退出vim 
let Tlist_Use_Right_Window = 1 "在右侧窗口中显示taglist窗口
" minibufexpl插件的一般设置
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplMapWindowNavArrows = 1
let g:miniBufExplMapCTabSwitchBufs = 1 
let g:miniBufExplModSelTarget = 1
```





```shell
home目录中创建一个 .vimrc文件

vim ~/.vimrc

# 文件基本配置################################################################################################

" 设置当文件被改动时自动载入

set autoread

" quickfix模式

autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>

"代码补全

set completeopt=preview,menu

"允许插件

filetype plugin on

"共享剪贴板

set clipboard=unnamed

"从不备份

set nobackup

"make 运行

:set makeprg=g++\ -Wall\ \ %

"自动保存

set autowrite

set ruler " 打开状态栏标尺

set cursorline " 突出显示当前行

set magic " 设置魔术

set guioptions-=T " 隐藏工具栏

set guioptions-=m " 隐藏菜单栏

"set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\

" 设置在状态行显示的信息

set foldcolumn=0

set foldmethod=indent

set foldlevel=3

set foldenable " 开始折叠

" 不要使用vi的键盘模式，而是vim自己的

set nocompatible

" 语法高亮

set syntax=on

" 去掉输入错误的提示声音

set noeb

" 在处理未保存或只读文件的时候，弹出确认

set confirm

" 自动缩进

set autoindent

set cindent

" Tab键的宽度

set tabstop=4

" 统一缩进为4

set softtabstop=4

set shiftwidth=4

" 不要用空格代替制表符

set noexpandtab

" 在行和段开始处使用制表符

set smarttab

" 显示行号

set number

" 历史记录数

set history=1000

"禁止生成临时文件

set nobackup

set noswapfile

"搜索忽略大小写

set ignorecase

"搜索逐字符高亮

set hlsearch

set incsearch

"行内替换

set gdefault

"编码设置

set enc=utf-8

set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936

"语言设置

set langmenu=zh_CN.UTF-8

set helplang=cn

" 我的状态行显示的内容（包括文件类型和解码）

set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}

set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]

" 总是显示状态行

set laststatus=2

" 命令行（在状态行下）的高度，默认为1，这里是2

set cmdheight=2

" 侦测文件类型

filetype on

" 载入文件类型插件

filetype plugin on

" 为特定文件类型载入相关缩进文件

filetype indent on

" 保存全局变量

set viminfo+=!

" 带有如下符号的单词不要被换行分割

set iskeyword+=_,$,@,%,#,-

" 字符间插入的像素行数目

set linespace=0

" 增强模式中的命令行自动完成操作

set wildmenu

" 使回格键（backspace）正常处理indent, eol, start等

set backspace=2

" 允许backspace和光标键跨越行边界

set whichwrap+=<,>,h,l

" 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）

set mouse=a

set selection=exclusive

set selectmode=mouse,key

" 通过使用: commands命令，告诉我们文件的哪一行被改变过

set report=0

" 在被分割的窗口间显示空白，便于阅读

set fillchars=vert:\ ,stl:\ ,stlnc:\

" 高亮显示匹配的括号

set showmatch

" 匹配括号高亮的时间（单位是十分之一秒）

set matchtime=1

" 光标移动到buffer的顶部和底部时保持3行距离

set scrolloff=3

" 为C程序提供自动缩进

set smartindent

" 高亮显示普通txt文件（需要txt.vim脚本）

au BufRead,BufNewFile * setfiletype txt

"自动补全

:inoremap ( ()<ESC>i

:inoremap ) <c-r>=ClosePair(')')<CR>

":inoremap { {<CR>}<ESC>O

":inoremap } <c-r>=ClosePair('}')<CR>

:inoremap [ []<ESC>i

:inoremap ] <c-r>=ClosePair(']')<CR>

:inoremap " ""<ESC>i

:inoremap ' ''<ESC>i

function! ClosePair(char)

if getline('.')[col('.') - 1] == a:char

return "\<Right>"

else

return a:char

endif

endfunction

filetype plugin indent on

"打开文件类型检测, 加了这句才可以用智能补全

set completeopt=longest,menu

```



vim的终级插件
CentOS下：yum erase emacs
Ubuntu下：apt-get remove emacs

# 十、参考
[vim官方文档](https://yianwillis.github.io/vimcdoc/doc/help.html)
https://yyq123.github.io/learn-vim/learn-vi-09-word.html

[vim命令大全](https://zhuanlan.zhihu.com/p/61515833)

[vim从嫌弃到依赖系列](/https://www.cnblogs.com/lanuage/category/2138131.html?page=2)

[简明 VIM 练级攻略](https://coolshell.cn/articles/5426.html)





![img](https://mielgo-markdown.oss-cn-chengdu.aliyuncs.com/linux_vim%E9%94%AE%E4%BD%8D%E5%9B%BE.webp)